// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: memcache.proto

#ifndef PROTOBUF_memcache_2eproto__INCLUDED
#define PROTOBUF_memcache_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2003000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2003000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
#ifdef _WEB_LOGIC
#include "CharSetUtil.hpp"
#endif
// @@protoc_insertion_point(includes)

namespace comm {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_memcache_2eproto();
void protobuf_AssignDesc_memcache_2eproto();
void protobuf_ShutdownFile_memcache_2eproto();

class AttrVal;
class MtMemcacheMachineAttrDayVal;
class MonitorMemcache;
class MemcTimeInfo;
class MemcTimeInfoAll;
class MemcViewInfo;
class MemcMachineInfo;
class MemcAttrTypeInfo;
class MemcAttrInfo;
class MemcUserAttrInfo;
class MemcUserAttrTypeInfo;
class MmapUserAttrTypeTree;

enum AttrInfoFlag {
  ATTR_INFO_FLAG_GLOBAL = 1,
  ATTR_INFO_FLAG_MASK = 2
};
bool AttrInfoFlag_IsValid(int value);
const AttrInfoFlag AttrInfoFlag_MIN = ATTR_INFO_FLAG_GLOBAL;
const AttrInfoFlag AttrInfoFlag_MAX = ATTR_INFO_FLAG_MASK;
const int AttrInfoFlag_ARRAYSIZE = AttrInfoFlag_MAX + 1;

const ::google::protobuf::EnumDescriptor* AttrInfoFlag_descriptor();
inline const ::std::string& AttrInfoFlag_Name(AttrInfoFlag value) {
  return ::google::protobuf::internal::NameOfEnum(
    AttrInfoFlag_descriptor(), value);
}
inline bool AttrInfoFlag_Parse(
    const ::std::string& name, AttrInfoFlag* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AttrInfoFlag>(
    AttrInfoFlag_descriptor(), name, value);
}
// ===================================================================

class AttrVal : public ::google::protobuf::Message {
 public:
  AttrVal();
  virtual ~AttrVal();
  
  AttrVal(const AttrVal& from);
  
  inline AttrVal& operator=(const AttrVal& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AttrVal& default_instance();
  
  void Swap(AttrVal* other);
  
  // implements Message ----------------------------------------------
  
  AttrVal* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AttrVal& from);
  void MergeFrom(const AttrVal& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional uint32 idx = 1;
  inline bool has_idx() const;
  inline void clear_idx();
  static const int kIdxFieldNumber = 1;
  inline ::google::protobuf::uint32 idx() const;
  inline void set_idx(::google::protobuf::uint32 value);
  
  // optional uint32 val = 2;
  inline bool has_val() const;
  inline void clear_val();
  static const int kValFieldNumber = 2;
  inline ::google::protobuf::uint32 val() const;
  inline void set_val(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:comm.AttrVal)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::uint32 idx_;
  ::google::protobuf::uint32 val_;
  friend void  protobuf_AddDesc_memcache_2eproto();
  friend void protobuf_AssignDesc_memcache_2eproto();
  friend void protobuf_ShutdownFile_memcache_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static AttrVal* default_instance_;
};
// -------------------------------------------------------------------

class MtMemcacheMachineAttrDayVal : public ::google::protobuf::Message {
 public:
  MtMemcacheMachineAttrDayVal();
  virtual ~MtMemcacheMachineAttrDayVal();
  
  MtMemcacheMachineAttrDayVal(const MtMemcacheMachineAttrDayVal& from);
  
  inline MtMemcacheMachineAttrDayVal& operator=(const MtMemcacheMachineAttrDayVal& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MtMemcacheMachineAttrDayVal& default_instance();
  
  void Swap(MtMemcacheMachineAttrDayVal* other);
  
  // implements Message ----------------------------------------------
  
  MtMemcacheMachineAttrDayVal* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MtMemcacheMachineAttrDayVal& from);
  void MergeFrom(const MtMemcacheMachineAttrDayVal& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .comm.AttrVal attr_val = 1;
  inline int attr_val_size() const;
  inline void clear_attr_val();
  static const int kAttrValFieldNumber = 1;
  inline const ::comm::AttrVal& attr_val(int index) const;
  inline ::comm::AttrVal* mutable_attr_val(int index);
  inline ::comm::AttrVal* add_attr_val();
  inline const ::google::protobuf::RepeatedPtrField< ::comm::AttrVal >&
      attr_val() const;
  inline ::google::protobuf::RepeatedPtrField< ::comm::AttrVal >*
      mutable_attr_val();
  
  // optional uint32 max_idx = 2 [default = 0];
  inline bool has_max_idx() const;
  inline void clear_max_idx();
  static const int kMaxIdxFieldNumber = 2;
  inline ::google::protobuf::uint32 max_idx() const;
  inline void set_max_idx(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:comm.MtMemcacheMachineAttrDayVal)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::comm::AttrVal > attr_val_;
  ::google::protobuf::uint32 max_idx_;
  friend void  protobuf_AddDesc_memcache_2eproto();
  friend void protobuf_AssignDesc_memcache_2eproto();
  friend void protobuf_ShutdownFile_memcache_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MtMemcacheMachineAttrDayVal* default_instance_;
};
// -------------------------------------------------------------------

class MonitorMemcache : public ::google::protobuf::Message {
 public:
  MonitorMemcache();
  virtual ~MonitorMemcache();
  
  MonitorMemcache(const MonitorMemcache& from);
  
  inline MonitorMemcache& operator=(const MonitorMemcache& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MonitorMemcache& default_instance();
  
  void Swap(MonitorMemcache* other);
  
  // implements Message ----------------------------------------------
  
  MonitorMemcache* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MonitorMemcache& from);
  void MergeFrom(const MonitorMemcache& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .comm.MtMemcacheMachineAttrDayVal machine_attr_day_val = 1;
  inline bool has_machine_attr_day_val() const;
  inline void clear_machine_attr_day_val();
  static const int kMachineAttrDayValFieldNumber = 1;
  inline const ::comm::MtMemcacheMachineAttrDayVal& machine_attr_day_val() const;
  inline ::comm::MtMemcacheMachineAttrDayVal* mutable_machine_attr_day_val();
  
  // optional uint32 now_static_val = 2;
  inline bool has_now_static_val() const;
  inline void clear_now_static_val();
  static const int kNowStaticValFieldNumber = 2;
  inline ::google::protobuf::uint32 now_static_val() const;
  inline void set_now_static_val(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:comm.MonitorMemcache)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::comm::MtMemcacheMachineAttrDayVal* machine_attr_day_val_;
  ::google::protobuf::uint32 now_static_val_;
  friend void  protobuf_AddDesc_memcache_2eproto();
  friend void protobuf_AssignDesc_memcache_2eproto();
  friend void protobuf_ShutdownFile_memcache_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MonitorMemcache* default_instance_;
};
// -------------------------------------------------------------------

class MemcTimeInfo : public ::google::protobuf::Message {
 public:
  MemcTimeInfo();
  virtual ~MemcTimeInfo();
  
  MemcTimeInfo(const MemcTimeInfo& from);
  
  inline MemcTimeInfo& operator=(const MemcTimeInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MemcTimeInfo& default_instance();
  
  void Swap(MemcTimeInfo* other);
  
  // implements Message ----------------------------------------------
  
  MemcTimeInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MemcTimeInfo& from);
  void MergeFrom(const MemcTimeInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);
  
  // optional uint32 time = 2;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 2;
  inline ::google::protobuf::uint32 time() const;
  inline void set_time(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:comm.MemcTimeInfo)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::uint32 id_;
  ::google::protobuf::uint32 time_;
  friend void  protobuf_AddDesc_memcache_2eproto();
  friend void protobuf_AssignDesc_memcache_2eproto();
  friend void protobuf_ShutdownFile_memcache_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MemcTimeInfo* default_instance_;
};
// -------------------------------------------------------------------

class MemcTimeInfoAll : public ::google::protobuf::Message {
 public:
  MemcTimeInfoAll();
  virtual ~MemcTimeInfoAll();
  
  MemcTimeInfoAll(const MemcTimeInfoAll& from);
  
  inline MemcTimeInfoAll& operator=(const MemcTimeInfoAll& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MemcTimeInfoAll& default_instance();
  
  void Swap(MemcTimeInfoAll* other);
  
  // implements Message ----------------------------------------------
  
  MemcTimeInfoAll* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MemcTimeInfoAll& from);
  void MergeFrom(const MemcTimeInfoAll& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .comm.MemcTimeInfo info = 1;
  inline int info_size() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 1;
  inline const ::comm::MemcTimeInfo& info(int index) const;
  inline ::comm::MemcTimeInfo* mutable_info(int index);
  inline ::comm::MemcTimeInfo* add_info();
  inline const ::google::protobuf::RepeatedPtrField< ::comm::MemcTimeInfo >&
      info() const;
  inline ::google::protobuf::RepeatedPtrField< ::comm::MemcTimeInfo >*
      mutable_info();
  
  // @@protoc_insertion_point(class_scope:comm.MemcTimeInfoAll)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::comm::MemcTimeInfo > info_;
  friend void  protobuf_AddDesc_memcache_2eproto();
  friend void protobuf_AssignDesc_memcache_2eproto();
  friend void protobuf_ShutdownFile_memcache_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MemcTimeInfoAll* default_instance_;
};
// -------------------------------------------------------------------

class MemcViewInfo : public ::google::protobuf::Message {
 public:
  MemcViewInfo();
  virtual ~MemcViewInfo();
  
  MemcViewInfo(const MemcViewInfo& from);
  
  inline MemcViewInfo& operator=(const MemcViewInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MemcViewInfo& default_instance();
  
  void Swap(MemcViewInfo* other);
  
  // implements Message ----------------------------------------------
  
  MemcViewInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MemcViewInfo& from);
  void MergeFrom(const MemcViewInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string view_name = 1;
  inline bool has_view_name() const;
  inline void clear_view_name();
  static const int kViewNameFieldNumber = 1;
  inline const ::std::string& view_name() const;
  inline void set_view_name(const ::std::string& value);
  inline void set_view_name(const char* value);
  inline void set_view_name(const char* value, size_t size);
  inline ::std::string* mutable_view_name();
  
  // @@protoc_insertion_point(class_scope:comm.MemcViewInfo)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* view_name_;
  static const ::std::string _default_view_name_;
  friend void  protobuf_AddDesc_memcache_2eproto();
  friend void protobuf_AssignDesc_memcache_2eproto();
  friend void protobuf_ShutdownFile_memcache_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MemcViewInfo* default_instance_;
};
// -------------------------------------------------------------------

class MemcMachineInfo : public ::google::protobuf::Message {
 public:
  MemcMachineInfo();
  virtual ~MemcMachineInfo();
  
  MemcMachineInfo(const MemcMachineInfo& from);
  
  inline MemcMachineInfo& operator=(const MemcMachineInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MemcMachineInfo& default_instance();
  
  void Swap(MemcMachineInfo* other);
  
  // implements Message ----------------------------------------------
  
  MemcMachineInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MemcMachineInfo& from);
  void MergeFrom(const MemcMachineInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional uint32 ip1 = 1;
  inline bool has_ip1() const;
  inline void clear_ip1();
  static const int kIp1FieldNumber = 1;
  inline ::google::protobuf::uint32 ip1() const;
  inline void set_ip1(::google::protobuf::uint32 value);
  
  // optional uint32 ip2 = 2;
  inline bool has_ip2() const;
  inline void clear_ip2();
  static const int kIp2FieldNumber = 2;
  inline ::google::protobuf::uint32 ip2() const;
  inline void set_ip2(::google::protobuf::uint32 value);
  
  // optional uint32 ip3 = 3;
  inline bool has_ip3() const;
  inline void clear_ip3();
  static const int kIp3FieldNumber = 3;
  inline ::google::protobuf::uint32 ip3() const;
  inline void set_ip3(::google::protobuf::uint32 value);
  
  // optional uint32 ip4 = 4;
  inline bool has_ip4() const;
  inline void clear_ip4();
  static const int kIp4FieldNumber = 4;
  inline ::google::protobuf::uint32 ip4() const;
  inline void set_ip4(::google::protobuf::uint32 value);
  
  // optional string name = 5;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 5;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  
  // @@protoc_insertion_point(class_scope:comm.MemcMachineInfo)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::uint32 ip1_;
  ::google::protobuf::uint32 ip2_;
  ::google::protobuf::uint32 ip3_;
  ::google::protobuf::uint32 ip4_;
  ::std::string* name_;
  static const ::std::string _default_name_;
  friend void  protobuf_AddDesc_memcache_2eproto();
  friend void protobuf_AssignDesc_memcache_2eproto();
  friend void protobuf_ShutdownFile_memcache_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MemcMachineInfo* default_instance_;
};
// -------------------------------------------------------------------

class MemcAttrTypeInfo : public ::google::protobuf::Message {
 public:
  MemcAttrTypeInfo();
  virtual ~MemcAttrTypeInfo();
  
  MemcAttrTypeInfo(const MemcAttrTypeInfo& from);
  
  inline MemcAttrTypeInfo& operator=(const MemcAttrTypeInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MemcAttrTypeInfo& default_instance();
  
  void Swap(MemcAttrTypeInfo* other);
  
  // implements Message ----------------------------------------------
  
  MemcAttrTypeInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MemcAttrTypeInfo& from);
  void MergeFrom(const MemcAttrTypeInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string attr_type_name = 1;
  inline bool has_attr_type_name() const;
  inline void clear_attr_type_name();
  static const int kAttrTypeNameFieldNumber = 1;
  inline const ::std::string& attr_type_name() const;
  inline void set_attr_type_name(const ::std::string& value);
  inline void set_attr_type_name(const char* value);
  inline void set_attr_type_name(const char* value, size_t size);
  inline ::std::string* mutable_attr_type_name();
  
  // optional int32 attr_type_id = 2;
  inline bool has_attr_type_id() const;
  inline void clear_attr_type_id();
  static const int kAttrTypeIdFieldNumber = 2;
  inline ::google::protobuf::int32 attr_type_id() const;
  inline void set_attr_type_id(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:comm.MemcAttrTypeInfo)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* attr_type_name_;
  static const ::std::string _default_attr_type_name_;
  ::google::protobuf::int32 attr_type_id_;
  friend void  protobuf_AddDesc_memcache_2eproto();
  friend void protobuf_AssignDesc_memcache_2eproto();
  friend void protobuf_ShutdownFile_memcache_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MemcAttrTypeInfo* default_instance_;
};
// -------------------------------------------------------------------

class MemcAttrInfo : public ::google::protobuf::Message {
 public:
  MemcAttrInfo();
  virtual ~MemcAttrInfo();
  
  MemcAttrInfo(const MemcAttrInfo& from);
  
  inline MemcAttrInfo& operator=(const MemcAttrInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MemcAttrInfo& default_instance();
  
  void Swap(MemcAttrInfo* other);
  
  // implements Message ----------------------------------------------
  
  MemcAttrInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MemcAttrInfo& from);
  void MergeFrom(const MemcAttrInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string attr_name = 1;
  inline bool has_attr_name() const;
  inline void clear_attr_name();
  static const int kAttrNameFieldNumber = 1;
  inline const ::std::string& attr_name() const;
  inline void set_attr_name(const ::std::string& value);
  inline void set_attr_name(const char* value);
  inline void set_attr_name(const char* value, size_t size);
  inline ::std::string* mutable_attr_name();
  
  // @@protoc_insertion_point(class_scope:comm.MemcAttrInfo)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* attr_name_;
  static const ::std::string _default_attr_name_;
  friend void  protobuf_AddDesc_memcache_2eproto();
  friend void protobuf_AssignDesc_memcache_2eproto();
  friend void protobuf_ShutdownFile_memcache_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MemcAttrInfo* default_instance_;
};
// -------------------------------------------------------------------

class MemcUserAttrInfo : public ::google::protobuf::Message {
 public:
  MemcUserAttrInfo();
  virtual ~MemcUserAttrInfo();
  
  MemcUserAttrInfo(const MemcUserAttrInfo& from);
  
  inline MemcUserAttrInfo& operator=(const MemcUserAttrInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MemcUserAttrInfo& default_instance();
  
  void Swap(MemcUserAttrInfo* other);
  
  // implements Message ----------------------------------------------
  
  MemcUserAttrInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MemcUserAttrInfo& from);
  void MergeFrom(const MemcUserAttrInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional uint32 attr_info_seq = 1;
  inline bool has_attr_info_seq() const;
  inline void clear_attr_info_seq();
  static const int kAttrInfoSeqFieldNumber = 1;
  inline ::google::protobuf::uint32 attr_info_seq() const;
  inline void set_attr_info_seq(::google::protobuf::uint32 value);
  
  // repeated .comm.MemcAttrInfo attr_list = 2;
  inline int attr_list_size() const;
  inline void clear_attr_list();
  static const int kAttrListFieldNumber = 2;
  inline const ::comm::MemcAttrInfo& attr_list(int index) const;
  inline ::comm::MemcAttrInfo* mutable_attr_list(int index);
  inline ::comm::MemcAttrInfo* add_attr_list();
  inline const ::google::protobuf::RepeatedPtrField< ::comm::MemcAttrInfo >&
      attr_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::comm::MemcAttrInfo >*
      mutable_attr_list();
  
  // @@protoc_insertion_point(class_scope:comm.MemcUserAttrInfo)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::uint32 attr_info_seq_;
  ::google::protobuf::RepeatedPtrField< ::comm::MemcAttrInfo > attr_list_;
  friend void  protobuf_AddDesc_memcache_2eproto();
  friend void protobuf_AssignDesc_memcache_2eproto();
  friend void protobuf_ShutdownFile_memcache_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MemcUserAttrInfo* default_instance_;
};
// -------------------------------------------------------------------

class MemcUserAttrTypeInfo : public ::google::protobuf::Message {
 public:
  MemcUserAttrTypeInfo();
  virtual ~MemcUserAttrTypeInfo();
  
  MemcUserAttrTypeInfo(const MemcUserAttrTypeInfo& from);
  
  inline MemcUserAttrTypeInfo& operator=(const MemcUserAttrTypeInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MemcUserAttrTypeInfo& default_instance();
  
  void Swap(MemcUserAttrTypeInfo* other);
  
  // implements Message ----------------------------------------------
  
  MemcUserAttrTypeInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MemcUserAttrTypeInfo& from);
  void MergeFrom(const MemcUserAttrTypeInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional uint32 attr_type_info_seq = 1;
  inline bool has_attr_type_info_seq() const;
  inline void clear_attr_type_info_seq();
  static const int kAttrTypeInfoSeqFieldNumber = 1;
  inline ::google::protobuf::uint32 attr_type_info_seq() const;
  inline void set_attr_type_info_seq(::google::protobuf::uint32 value);
  
  // repeated .comm.MemcAttrTypeInfo attr_type_list = 2;
  inline int attr_type_list_size() const;
  inline void clear_attr_type_list();
  static const int kAttrTypeListFieldNumber = 2;
  inline const ::comm::MemcAttrTypeInfo& attr_type_list(int index) const;
  inline ::comm::MemcAttrTypeInfo* mutable_attr_type_list(int index);
  inline ::comm::MemcAttrTypeInfo* add_attr_type_list();
  inline const ::google::protobuf::RepeatedPtrField< ::comm::MemcAttrTypeInfo >&
      attr_type_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::comm::MemcAttrTypeInfo >*
      mutable_attr_type_list();
  
  // @@protoc_insertion_point(class_scope:comm.MemcUserAttrTypeInfo)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::uint32 attr_type_info_seq_;
  ::google::protobuf::RepeatedPtrField< ::comm::MemcAttrTypeInfo > attr_type_list_;
  friend void  protobuf_AddDesc_memcache_2eproto();
  friend void protobuf_AssignDesc_memcache_2eproto();
  friend void protobuf_ShutdownFile_memcache_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MemcUserAttrTypeInfo* default_instance_;
};
// -------------------------------------------------------------------

class MmapUserAttrTypeTree : public ::google::protobuf::Message {
 public:
  MmapUserAttrTypeTree();
  virtual ~MmapUserAttrTypeTree();
  
  MmapUserAttrTypeTree(const MmapUserAttrTypeTree& from);
  
  inline MmapUserAttrTypeTree& operator=(const MmapUserAttrTypeTree& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MmapUserAttrTypeTree& default_instance();
  
  void Swap(MmapUserAttrTypeTree* other);
  
  // implements Message ----------------------------------------------
  
  MmapUserAttrTypeTree* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MmapUserAttrTypeTree& from);
  void MergeFrom(const MmapUserAttrTypeTree& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 attr_type_id = 1;
  inline bool has_attr_type_id() const;
  inline void clear_attr_type_id();
  static const int kAttrTypeIdFieldNumber = 1;
  inline ::google::protobuf::int32 attr_type_id() const;
  inline void set_attr_type_id(::google::protobuf::int32 value);
  
  // repeated .comm.MmapUserAttrTypeTree sub_type_list = 2;
  inline int sub_type_list_size() const;
  inline void clear_sub_type_list();
  static const int kSubTypeListFieldNumber = 2;
  inline const ::comm::MmapUserAttrTypeTree& sub_type_list(int index) const;
  inline ::comm::MmapUserAttrTypeTree* mutable_sub_type_list(int index);
  inline ::comm::MmapUserAttrTypeTree* add_sub_type_list();
  inline const ::google::protobuf::RepeatedPtrField< ::comm::MmapUserAttrTypeTree >&
      sub_type_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::comm::MmapUserAttrTypeTree >*
      mutable_sub_type_list();
  
  // @@protoc_insertion_point(class_scope:comm.MmapUserAttrTypeTree)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::int32 attr_type_id_;
  ::google::protobuf::RepeatedPtrField< ::comm::MmapUserAttrTypeTree > sub_type_list_;
  friend void  protobuf_AddDesc_memcache_2eproto();
  friend void protobuf_AssignDesc_memcache_2eproto();
  friend void protobuf_ShutdownFile_memcache_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MmapUserAttrTypeTree* default_instance_;
};
// ===================================================================


// ===================================================================

// AttrVal

// optional uint32 idx = 1;
inline bool AttrVal::has_idx() const {
  return _has_bit(0);
}
inline void AttrVal::clear_idx() {
  idx_ = 0u;
  _clear_bit(0);
}
inline ::google::protobuf::uint32 AttrVal::idx() const {
  return idx_;
}
inline void AttrVal::set_idx(::google::protobuf::uint32 value) {
  _set_bit(0);
  idx_ = value;
}

// optional uint32 val = 2;
inline bool AttrVal::has_val() const {
  return _has_bit(1);
}
inline void AttrVal::clear_val() {
  val_ = 0u;
  _clear_bit(1);
}
inline ::google::protobuf::uint32 AttrVal::val() const {
  return val_;
}
inline void AttrVal::set_val(::google::protobuf::uint32 value) {
  _set_bit(1);
  val_ = value;
}

// -------------------------------------------------------------------

// MtMemcacheMachineAttrDayVal

// repeated .comm.AttrVal attr_val = 1;
inline int MtMemcacheMachineAttrDayVal::attr_val_size() const {
  return attr_val_.size();
}
inline void MtMemcacheMachineAttrDayVal::clear_attr_val() {
  attr_val_.Clear();
}
inline const ::comm::AttrVal& MtMemcacheMachineAttrDayVal::attr_val(int index) const {
  return attr_val_.Get(index);
}
inline ::comm::AttrVal* MtMemcacheMachineAttrDayVal::mutable_attr_val(int index) {
  return attr_val_.Mutable(index);
}
inline ::comm::AttrVal* MtMemcacheMachineAttrDayVal::add_attr_val() {
  return attr_val_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::comm::AttrVal >&
MtMemcacheMachineAttrDayVal::attr_val() const {
  return attr_val_;
}
inline ::google::protobuf::RepeatedPtrField< ::comm::AttrVal >*
MtMemcacheMachineAttrDayVal::mutable_attr_val() {
  return &attr_val_;
}

// optional uint32 max_idx = 2 [default = 0];
inline bool MtMemcacheMachineAttrDayVal::has_max_idx() const {
  return _has_bit(1);
}
inline void MtMemcacheMachineAttrDayVal::clear_max_idx() {
  max_idx_ = 0u;
  _clear_bit(1);
}
inline ::google::protobuf::uint32 MtMemcacheMachineAttrDayVal::max_idx() const {
  return max_idx_;
}
inline void MtMemcacheMachineAttrDayVal::set_max_idx(::google::protobuf::uint32 value) {
  _set_bit(1);
  max_idx_ = value;
}

// -------------------------------------------------------------------

// MonitorMemcache

// optional .comm.MtMemcacheMachineAttrDayVal machine_attr_day_val = 1;
inline bool MonitorMemcache::has_machine_attr_day_val() const {
  return _has_bit(0);
}
inline void MonitorMemcache::clear_machine_attr_day_val() {
  if (machine_attr_day_val_ != NULL) machine_attr_day_val_->::comm::MtMemcacheMachineAttrDayVal::Clear();
  _clear_bit(0);
}
inline const ::comm::MtMemcacheMachineAttrDayVal& MonitorMemcache::machine_attr_day_val() const {
  return machine_attr_day_val_ != NULL ? *machine_attr_day_val_ : *default_instance_->machine_attr_day_val_;
}
inline ::comm::MtMemcacheMachineAttrDayVal* MonitorMemcache::mutable_machine_attr_day_val() {
  _set_bit(0);
  if (machine_attr_day_val_ == NULL) machine_attr_day_val_ = new ::comm::MtMemcacheMachineAttrDayVal;
  return machine_attr_day_val_;
}

// optional uint32 now_static_val = 2;
inline bool MonitorMemcache::has_now_static_val() const {
  return _has_bit(1);
}
inline void MonitorMemcache::clear_now_static_val() {
  now_static_val_ = 0u;
  _clear_bit(1);
}
inline ::google::protobuf::uint32 MonitorMemcache::now_static_val() const {
  return now_static_val_;
}
inline void MonitorMemcache::set_now_static_val(::google::protobuf::uint32 value) {
  _set_bit(1);
  now_static_val_ = value;
}

// -------------------------------------------------------------------

// MemcTimeInfo

// optional uint32 id = 1;
inline bool MemcTimeInfo::has_id() const {
  return _has_bit(0);
}
inline void MemcTimeInfo::clear_id() {
  id_ = 0u;
  _clear_bit(0);
}
inline ::google::protobuf::uint32 MemcTimeInfo::id() const {
  return id_;
}
inline void MemcTimeInfo::set_id(::google::protobuf::uint32 value) {
  _set_bit(0);
  id_ = value;
}

// optional uint32 time = 2;
inline bool MemcTimeInfo::has_time() const {
  return _has_bit(1);
}
inline void MemcTimeInfo::clear_time() {
  time_ = 0u;
  _clear_bit(1);
}
inline ::google::protobuf::uint32 MemcTimeInfo::time() const {
  return time_;
}
inline void MemcTimeInfo::set_time(::google::protobuf::uint32 value) {
  _set_bit(1);
  time_ = value;
}

// -------------------------------------------------------------------

// MemcTimeInfoAll

// repeated .comm.MemcTimeInfo info = 1;
inline int MemcTimeInfoAll::info_size() const {
  return info_.size();
}
inline void MemcTimeInfoAll::clear_info() {
  info_.Clear();
}
inline const ::comm::MemcTimeInfo& MemcTimeInfoAll::info(int index) const {
  return info_.Get(index);
}
inline ::comm::MemcTimeInfo* MemcTimeInfoAll::mutable_info(int index) {
  return info_.Mutable(index);
}
inline ::comm::MemcTimeInfo* MemcTimeInfoAll::add_info() {
  return info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::comm::MemcTimeInfo >&
MemcTimeInfoAll::info() const {
  return info_;
}
inline ::google::protobuf::RepeatedPtrField< ::comm::MemcTimeInfo >*
MemcTimeInfoAll::mutable_info() {
  return &info_;
}

// -------------------------------------------------------------------

// MemcViewInfo

// optional string view_name = 1;
inline bool MemcViewInfo::has_view_name() const {
  return _has_bit(0);
}
inline void MemcViewInfo::clear_view_name() {
  if (view_name_ != &_default_view_name_) {
    view_name_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& MemcViewInfo::view_name() const {
  return *view_name_;
}
#ifdef _WEB_LOGIC
inline void MemcViewInfo::set_view_name(const ::std::string& value) {
  _set_bit(0);
  if (view_name_ == &_default_view_name_) {
    view_name_ = new ::std::string;
  }
  string sTemp;
  StringUtil::GBK2UTF8(value.c_str(), value.size(), sTemp);
  view_name_->assign(sTemp);
}
inline void MemcViewInfo::set_view_name(const char* value) {
  _set_bit(0);
  if (view_name_ == &_default_view_name_) {
    view_name_ = new ::std::string;
  }
  string sTemp = value;
  StringUtil::GBK2UTF8(value, sTemp.size(), sTemp);
  view_name_->assign(sTemp);
}
inline void MemcViewInfo::set_view_name(const char* value, size_t size) {
  _set_bit(0);
  if (view_name_ == &_default_view_name_) {
    view_name_ = new ::std::string;
  }
  string sTemp;
  StringUtil::GBK2UTF8(value, size, sTemp);
  view_name_->assign(sTemp);
}
#else
inline void MemcViewInfo::set_view_name(const ::std::string& value) {
  _set_bit(0);
  if (view_name_ == &_default_view_name_) {
    view_name_ = new ::std::string;
  }
  view_name_->assign(value);
}
inline void MemcViewInfo::set_view_name(const char* value) {
  _set_bit(0);
  if (view_name_ == &_default_view_name_) {
    view_name_ = new ::std::string;
  }
  view_name_->assign(value);
}
inline void MemcViewInfo::set_view_name(const char* value, size_t size) {
  _set_bit(0);
  if (view_name_ == &_default_view_name_) {
    view_name_ = new ::std::string;
  }
  view_name_->assign(reinterpret_cast<const char*>(value), size);
}
#endif
inline ::std::string* MemcViewInfo::mutable_view_name() {
  _set_bit(0);
  if (view_name_ == &_default_view_name_) {
    view_name_ = new ::std::string;
  }
  return view_name_;
}

// -------------------------------------------------------------------

// MemcMachineInfo

// optional uint32 ip1 = 1;
inline bool MemcMachineInfo::has_ip1() const {
  return _has_bit(0);
}
inline void MemcMachineInfo::clear_ip1() {
  ip1_ = 0u;
  _clear_bit(0);
}
inline ::google::protobuf::uint32 MemcMachineInfo::ip1() const {
  return ip1_;
}
inline void MemcMachineInfo::set_ip1(::google::protobuf::uint32 value) {
  _set_bit(0);
  ip1_ = value;
}

// optional uint32 ip2 = 2;
inline bool MemcMachineInfo::has_ip2() const {
  return _has_bit(1);
}
inline void MemcMachineInfo::clear_ip2() {
  ip2_ = 0u;
  _clear_bit(1);
}
inline ::google::protobuf::uint32 MemcMachineInfo::ip2() const {
  return ip2_;
}
inline void MemcMachineInfo::set_ip2(::google::protobuf::uint32 value) {
  _set_bit(1);
  ip2_ = value;
}

// optional uint32 ip3 = 3;
inline bool MemcMachineInfo::has_ip3() const {
  return _has_bit(2);
}
inline void MemcMachineInfo::clear_ip3() {
  ip3_ = 0u;
  _clear_bit(2);
}
inline ::google::protobuf::uint32 MemcMachineInfo::ip3() const {
  return ip3_;
}
inline void MemcMachineInfo::set_ip3(::google::protobuf::uint32 value) {
  _set_bit(2);
  ip3_ = value;
}

// optional uint32 ip4 = 4;
inline bool MemcMachineInfo::has_ip4() const {
  return _has_bit(3);
}
inline void MemcMachineInfo::clear_ip4() {
  ip4_ = 0u;
  _clear_bit(3);
}
inline ::google::protobuf::uint32 MemcMachineInfo::ip4() const {
  return ip4_;
}
inline void MemcMachineInfo::set_ip4(::google::protobuf::uint32 value) {
  _set_bit(3);
  ip4_ = value;
}

// optional string name = 5;
inline bool MemcMachineInfo::has_name() const {
  return _has_bit(4);
}
inline void MemcMachineInfo::clear_name() {
  if (name_ != &_default_name_) {
    name_->clear();
  }
  _clear_bit(4);
}
inline const ::std::string& MemcMachineInfo::name() const {
  return *name_;
}
#ifdef _WEB_LOGIC
inline void MemcMachineInfo::set_name(const ::std::string& value) {
  _set_bit(4);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  string sTemp;
  StringUtil::GBK2UTF8(value.c_str(), value.size(), sTemp);
  name_->assign(sTemp);
}
inline void MemcMachineInfo::set_name(const char* value) {
  _set_bit(4);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  string sTemp = value;
  StringUtil::GBK2UTF8(value, sTemp.size(), sTemp);
  name_->assign(sTemp);
}
inline void MemcMachineInfo::set_name(const char* value, size_t size) {
  _set_bit(4);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  string sTemp;
  StringUtil::GBK2UTF8(value, size, sTemp);
  name_->assign(sTemp);
}
#else
inline void MemcMachineInfo::set_name(const ::std::string& value) {
  _set_bit(4);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void MemcMachineInfo::set_name(const char* value) {
  _set_bit(4);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void MemcMachineInfo::set_name(const char* value, size_t size) {
  _set_bit(4);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
#endif
inline ::std::string* MemcMachineInfo::mutable_name() {
  _set_bit(4);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  return name_;
}

// -------------------------------------------------------------------

// MemcAttrTypeInfo

// optional string attr_type_name = 1;
inline bool MemcAttrTypeInfo::has_attr_type_name() const {
  return _has_bit(0);
}
inline void MemcAttrTypeInfo::clear_attr_type_name() {
  if (attr_type_name_ != &_default_attr_type_name_) {
    attr_type_name_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& MemcAttrTypeInfo::attr_type_name() const {
  return *attr_type_name_;
}
#ifdef _WEB_LOGIC
inline void MemcAttrTypeInfo::set_attr_type_name(const ::std::string& value) {
  _set_bit(0);
  if (attr_type_name_ == &_default_attr_type_name_) {
    attr_type_name_ = new ::std::string;
  }
  string sTemp;
  StringUtil::GBK2UTF8(value.c_str(), value.size(), sTemp);
  attr_type_name_->assign(sTemp);
}
inline void MemcAttrTypeInfo::set_attr_type_name(const char* value) {
  _set_bit(0);
  if (attr_type_name_ == &_default_attr_type_name_) {
    attr_type_name_ = new ::std::string;
  }
  string sTemp = value;
  StringUtil::GBK2UTF8(value, sTemp.size(), sTemp);
  attr_type_name_->assign(sTemp);
}
inline void MemcAttrTypeInfo::set_attr_type_name(const char* value, size_t size) {
  _set_bit(0);
  if (attr_type_name_ == &_default_attr_type_name_) {
    attr_type_name_ = new ::std::string;
  }
  string sTemp;
  StringUtil::GBK2UTF8(value, size, sTemp);
  attr_type_name_->assign(sTemp);
}
#else
inline void MemcAttrTypeInfo::set_attr_type_name(const ::std::string& value) {
  _set_bit(0);
  if (attr_type_name_ == &_default_attr_type_name_) {
    attr_type_name_ = new ::std::string;
  }
  attr_type_name_->assign(value);
}
inline void MemcAttrTypeInfo::set_attr_type_name(const char* value) {
  _set_bit(0);
  if (attr_type_name_ == &_default_attr_type_name_) {
    attr_type_name_ = new ::std::string;
  }
  attr_type_name_->assign(value);
}
inline void MemcAttrTypeInfo::set_attr_type_name(const char* value, size_t size) {
  _set_bit(0);
  if (attr_type_name_ == &_default_attr_type_name_) {
    attr_type_name_ = new ::std::string;
  }
  attr_type_name_->assign(reinterpret_cast<const char*>(value), size);
}
#endif
inline ::std::string* MemcAttrTypeInfo::mutable_attr_type_name() {
  _set_bit(0);
  if (attr_type_name_ == &_default_attr_type_name_) {
    attr_type_name_ = new ::std::string;
  }
  return attr_type_name_;
}

// optional int32 attr_type_id = 2;
inline bool MemcAttrTypeInfo::has_attr_type_id() const {
  return _has_bit(1);
}
inline void MemcAttrTypeInfo::clear_attr_type_id() {
  attr_type_id_ = 0;
  _clear_bit(1);
}
inline ::google::protobuf::int32 MemcAttrTypeInfo::attr_type_id() const {
  return attr_type_id_;
}
inline void MemcAttrTypeInfo::set_attr_type_id(::google::protobuf::int32 value) {
  _set_bit(1);
  attr_type_id_ = value;
}

// -------------------------------------------------------------------

// MemcAttrInfo

// optional string attr_name = 1;
inline bool MemcAttrInfo::has_attr_name() const {
  return _has_bit(0);
}
inline void MemcAttrInfo::clear_attr_name() {
  if (attr_name_ != &_default_attr_name_) {
    attr_name_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& MemcAttrInfo::attr_name() const {
  return *attr_name_;
}
#ifdef _WEB_LOGIC
inline void MemcAttrInfo::set_attr_name(const ::std::string& value) {
  _set_bit(0);
  if (attr_name_ == &_default_attr_name_) {
    attr_name_ = new ::std::string;
  }
  string sTemp;
  StringUtil::GBK2UTF8(value.c_str(), value.size(), sTemp);
  attr_name_->assign(sTemp);
}
inline void MemcAttrInfo::set_attr_name(const char* value) {
  _set_bit(0);
  if (attr_name_ == &_default_attr_name_) {
    attr_name_ = new ::std::string;
  }
  string sTemp = value;
  StringUtil::GBK2UTF8(value, sTemp.size(), sTemp);
  attr_name_->assign(sTemp);
}
inline void MemcAttrInfo::set_attr_name(const char* value, size_t size) {
  _set_bit(0);
  if (attr_name_ == &_default_attr_name_) {
    attr_name_ = new ::std::string;
  }
  string sTemp;
  StringUtil::GBK2UTF8(value, size, sTemp);
  attr_name_->assign(sTemp);
}
#else
inline void MemcAttrInfo::set_attr_name(const ::std::string& value) {
  _set_bit(0);
  if (attr_name_ == &_default_attr_name_) {
    attr_name_ = new ::std::string;
  }
  attr_name_->assign(value);
}
inline void MemcAttrInfo::set_attr_name(const char* value) {
  _set_bit(0);
  if (attr_name_ == &_default_attr_name_) {
    attr_name_ = new ::std::string;
  }
  attr_name_->assign(value);
}
inline void MemcAttrInfo::set_attr_name(const char* value, size_t size) {
  _set_bit(0);
  if (attr_name_ == &_default_attr_name_) {
    attr_name_ = new ::std::string;
  }
  attr_name_->assign(reinterpret_cast<const char*>(value), size);
}
#endif
inline ::std::string* MemcAttrInfo::mutable_attr_name() {
  _set_bit(0);
  if (attr_name_ == &_default_attr_name_) {
    attr_name_ = new ::std::string;
  }
  return attr_name_;
}

// -------------------------------------------------------------------

// MemcUserAttrInfo

// optional uint32 attr_info_seq = 1;
inline bool MemcUserAttrInfo::has_attr_info_seq() const {
  return _has_bit(0);
}
inline void MemcUserAttrInfo::clear_attr_info_seq() {
  attr_info_seq_ = 0u;
  _clear_bit(0);
}
inline ::google::protobuf::uint32 MemcUserAttrInfo::attr_info_seq() const {
  return attr_info_seq_;
}
inline void MemcUserAttrInfo::set_attr_info_seq(::google::protobuf::uint32 value) {
  _set_bit(0);
  attr_info_seq_ = value;
}

// repeated .comm.MemcAttrInfo attr_list = 2;
inline int MemcUserAttrInfo::attr_list_size() const {
  return attr_list_.size();
}
inline void MemcUserAttrInfo::clear_attr_list() {
  attr_list_.Clear();
}
inline const ::comm::MemcAttrInfo& MemcUserAttrInfo::attr_list(int index) const {
  return attr_list_.Get(index);
}
inline ::comm::MemcAttrInfo* MemcUserAttrInfo::mutable_attr_list(int index) {
  return attr_list_.Mutable(index);
}
inline ::comm::MemcAttrInfo* MemcUserAttrInfo::add_attr_list() {
  return attr_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::comm::MemcAttrInfo >&
MemcUserAttrInfo::attr_list() const {
  return attr_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::comm::MemcAttrInfo >*
MemcUserAttrInfo::mutable_attr_list() {
  return &attr_list_;
}

// -------------------------------------------------------------------

// MemcUserAttrTypeInfo

// optional uint32 attr_type_info_seq = 1;
inline bool MemcUserAttrTypeInfo::has_attr_type_info_seq() const {
  return _has_bit(0);
}
inline void MemcUserAttrTypeInfo::clear_attr_type_info_seq() {
  attr_type_info_seq_ = 0u;
  _clear_bit(0);
}
inline ::google::protobuf::uint32 MemcUserAttrTypeInfo::attr_type_info_seq() const {
  return attr_type_info_seq_;
}
inline void MemcUserAttrTypeInfo::set_attr_type_info_seq(::google::protobuf::uint32 value) {
  _set_bit(0);
  attr_type_info_seq_ = value;
}

// repeated .comm.MemcAttrTypeInfo attr_type_list = 2;
inline int MemcUserAttrTypeInfo::attr_type_list_size() const {
  return attr_type_list_.size();
}
inline void MemcUserAttrTypeInfo::clear_attr_type_list() {
  attr_type_list_.Clear();
}
inline const ::comm::MemcAttrTypeInfo& MemcUserAttrTypeInfo::attr_type_list(int index) const {
  return attr_type_list_.Get(index);
}
inline ::comm::MemcAttrTypeInfo* MemcUserAttrTypeInfo::mutable_attr_type_list(int index) {
  return attr_type_list_.Mutable(index);
}
inline ::comm::MemcAttrTypeInfo* MemcUserAttrTypeInfo::add_attr_type_list() {
  return attr_type_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::comm::MemcAttrTypeInfo >&
MemcUserAttrTypeInfo::attr_type_list() const {
  return attr_type_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::comm::MemcAttrTypeInfo >*
MemcUserAttrTypeInfo::mutable_attr_type_list() {
  return &attr_type_list_;
}

// -------------------------------------------------------------------

// MmapUserAttrTypeTree

// optional int32 attr_type_id = 1;
inline bool MmapUserAttrTypeTree::has_attr_type_id() const {
  return _has_bit(0);
}
inline void MmapUserAttrTypeTree::clear_attr_type_id() {
  attr_type_id_ = 0;
  _clear_bit(0);
}
inline ::google::protobuf::int32 MmapUserAttrTypeTree::attr_type_id() const {
  return attr_type_id_;
}
inline void MmapUserAttrTypeTree::set_attr_type_id(::google::protobuf::int32 value) {
  _set_bit(0);
  attr_type_id_ = value;
}

// repeated .comm.MmapUserAttrTypeTree sub_type_list = 2;
inline int MmapUserAttrTypeTree::sub_type_list_size() const {
  return sub_type_list_.size();
}
inline void MmapUserAttrTypeTree::clear_sub_type_list() {
  sub_type_list_.Clear();
}
inline const ::comm::MmapUserAttrTypeTree& MmapUserAttrTypeTree::sub_type_list(int index) const {
  return sub_type_list_.Get(index);
}
inline ::comm::MmapUserAttrTypeTree* MmapUserAttrTypeTree::mutable_sub_type_list(int index) {
  return sub_type_list_.Mutable(index);
}
inline ::comm::MmapUserAttrTypeTree* MmapUserAttrTypeTree::add_sub_type_list() {
  return sub_type_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::comm::MmapUserAttrTypeTree >&
MmapUserAttrTypeTree::sub_type_list() const {
  return sub_type_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::comm::MmapUserAttrTypeTree >*
MmapUserAttrTypeTree::mutable_sub_type_list() {
  return &sub_type_list_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace comm

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< comm::AttrInfoFlag>() {
  return comm::AttrInfoFlag_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_memcache_2eproto__INCLUDED
