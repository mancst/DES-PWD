// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: user.proto

#ifndef PROTOBUF_user_2eproto__INCLUDED
#define PROTOBUF_user_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2003000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2003000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
#ifdef _WEB_LOGIC
#include "CharSetUtil.hpp"
#endif
// @@protoc_insertion_point(includes)

namespace user {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_user_2eproto();
void protobuf_AssignDesc_user_2eproto();
void protobuf_ShutdownFile_user_2eproto();

class UserSessionInfo;
class UserRemoteAppLogInfo;
class MainPagePluginTables;
class SystemOtherInfo;

enum MUSER_FLAG {
  MFLAG_WARN_SEND_FREQ = 2,
  MFLAG_WARN_SEND_ZB_ONLY = 4,
  MFLAG_WARN_SEND_ENABLE_TIME = 8,
  MFLAG_WARN_USE_EMAIL = 16,
  MFLAG_WARN_USE_MOBILE = 32,
  MFLAG_WARN_USE_PC_CLIENT = 64,
  MFLAG_WARN_USE_WEIXIN = 128
};
bool MUSER_FLAG_IsValid(int value);
const MUSER_FLAG MUSER_FLAG_MIN = MFLAG_WARN_SEND_FREQ;
const MUSER_FLAG MUSER_FLAG_MAX = MFLAG_WARN_USE_WEIXIN;
const int MUSER_FLAG_ARRAYSIZE = MUSER_FLAG_MAX + 1;

const ::google::protobuf::EnumDescriptor* MUSER_FLAG_descriptor();
inline const ::std::string& MUSER_FLAG_Name(MUSER_FLAG value) {
  return ::google::protobuf::internal::NameOfEnum(
    MUSER_FLAG_descriptor(), value);
}
inline bool MUSER_FLAG_Parse(
    const ::std::string& name, MUSER_FLAG* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MUSER_FLAG>(
    MUSER_FLAG_descriptor(), name, value);
}
enum OP_VCODE_TYPE {
  OP_VCODE_TYPE_EMAIL = 1
};
bool OP_VCODE_TYPE_IsValid(int value);
const OP_VCODE_TYPE OP_VCODE_TYPE_MIN = OP_VCODE_TYPE_EMAIL;
const OP_VCODE_TYPE OP_VCODE_TYPE_MAX = OP_VCODE_TYPE_EMAIL;
const int OP_VCODE_TYPE_ARRAYSIZE = OP_VCODE_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* OP_VCODE_TYPE_descriptor();
inline const ::std::string& OP_VCODE_TYPE_Name(OP_VCODE_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    OP_VCODE_TYPE_descriptor(), value);
}
inline bool OP_VCODE_TYPE_Parse(
    const ::std::string& name, OP_VCODE_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<OP_VCODE_TYPE>(
    OP_VCODE_TYPE_descriptor(), name, value);
}
// ===================================================================

class UserSessionInfo : public ::google::protobuf::Message {
 public:
  UserSessionInfo();
  virtual ~UserSessionInfo();
  
  UserSessionInfo(const UserSessionInfo& from);
  
  inline UserSessionInfo& operator=(const UserSessionInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const UserSessionInfo& default_instance();
  
  void Swap(UserSessionInfo* other);
  
  // implements Message ----------------------------------------------
  
  UserSessionInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UserSessionInfo& from);
  void MergeFrom(const UserSessionInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 bind_DES-PWE_uid = 1;
  inline bool has_bind_DES-PWE_uid() const;
  inline void clear_bind_DES-PWE_uid();
  static const int kBindDES-PWEUidFieldNumber = 1;
  inline ::google::protobuf::int32 bind_DES-PWE_uid() const;
  inline void set_bind_DES-PWE_uid(::google::protobuf::int32 value);
  
  // optional bytes bind_DES-PWE_key = 2;
  inline bool has_bind_DES-PWE_key() const;
  inline void clear_bind_DES-PWE_key();
  static const int kBindDES-PWEKeyFieldNumber = 2;
  inline const ::std::string& bind_DES-PWE_key() const;
  inline void set_bind_DES-PWE_key(const ::std::string& value);
  inline void set_bind_DES-PWE_key(const char* value);
  inline void set_bind_DES-PWE_key(const void* value, size_t size);
  inline ::std::string* mutable_bind_DES-PWE_key();
  
  // optional bytes email = 6;
  inline bool has_email() const;
  inline void clear_email();
  static const int kEmailFieldNumber = 6;
  inline const ::std::string& email() const;
  inline void set_email(const ::std::string& value);
  inline void set_email(const char* value);
  inline void set_email(const void* value, size_t size);
  inline ::std::string* mutable_email();
  
  // optional string mobile = 7;
  inline bool has_mobile() const;
  inline void clear_mobile();
  static const int kMobileFieldNumber = 7;
  inline const ::std::string& mobile() const;
  inline void set_mobile(const ::std::string& value);
  inline void set_mobile(const char* value);
  inline void set_mobile(const char* value, size_t size);
  inline ::std::string* mutable_mobile();
  
  // optional uint32 register_time = 8;
  inline bool has_register_time() const;
  inline void clear_register_time();
  static const int kRegisterTimeFieldNumber = 8;
  inline ::google::protobuf::uint32 register_time() const;
  inline void set_register_time(::google::protobuf::uint32 value);
  
  // optional uint32 op_code_set_time = 9;
  inline bool has_op_code_set_time() const;
  inline void clear_op_code_set_time();
  static const int kOpCodeSetTimeFieldNumber = 9;
  inline ::google::protobuf::uint32 op_code_set_time() const;
  inline void set_op_code_set_time(::google::protobuf::uint32 value);
  
  // optional string op_code_val = 10;
  inline bool has_op_code_val() const;
  inline void clear_op_code_val();
  static const int kOpCodeValFieldNumber = 10;
  inline const ::std::string& op_code_val() const;
  inline void set_op_code_val(const ::std::string& value);
  inline void set_op_code_val(const char* value);
  inline void set_op_code_val(const char* value, size_t size);
  inline ::std::string* mutable_op_code_val();
  
  // optional uint32 op_check_expire_time = 11;
  inline bool has_op_check_expire_time() const;
  inline void clear_op_check_expire_time();
  static const int kOpCheckExpireTimeFieldNumber = 11;
  inline ::google::protobuf::uint32 op_check_expire_time() const;
  inline void set_op_check_expire_time(::google::protobuf::uint32 value);
  
  // optional bytes op_new_email = 12;
  inline bool has_op_new_email() const;
  inline void clear_op_new_email();
  static const int kOpNewEmailFieldNumber = 12;
  inline const ::std::string& op_new_email() const;
  inline void set_op_new_email(const ::std::string& value);
  inline void set_op_new_email(const char* value);
  inline void set_op_new_email(const void* value, size_t size);
  inline ::std::string* mutable_op_new_email();
  
  // optional uint32 su_op_user_id = 14;
  inline bool has_su_op_user_id() const;
  inline void clear_su_op_user_id();
  static const int kSuOpUserIdFieldNumber = 14;
  inline ::google::protobuf::uint32 su_op_user_id() const;
  inline void set_su_op_user_id(::google::protobuf::uint32 value);
  
  // optional int32 op_code_type = 15;
  inline bool has_op_code_type() const;
  inline void clear_op_code_type();
  static const int kOpCodeTypeFieldNumber = 15;
  inline ::google::protobuf::int32 op_code_type() const;
  inline void set_op_code_type(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:user.UserSessionInfo)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::int32 bind_DES-PWE_uid_;
  ::std::string* bind_DES-PWE_key_;
  static const ::std::string _default_bind_DES-PWE_key_;
  ::std::string* email_;
  static const ::std::string _default_email_;
  ::std::string* mobile_;
  static const ::std::string _default_mobile_;
  ::google::protobuf::uint32 register_time_;
  ::google::protobuf::uint32 op_code_set_time_;
  ::std::string* op_code_val_;
  static const ::std::string _default_op_code_val_;
  ::google::protobuf::uint32 op_check_expire_time_;
  ::std::string* op_new_email_;
  static const ::std::string _default_op_new_email_;
  ::google::protobuf::uint32 su_op_user_id_;
  ::google::protobuf::int32 op_code_type_;
  friend void  protobuf_AddDesc_user_2eproto();
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static UserSessionInfo* default_instance_;
};
// -------------------------------------------------------------------

class UserRemoteAppLogInfo : public ::google::protobuf::Message {
 public:
  UserRemoteAppLogInfo();
  virtual ~UserRemoteAppLogInfo();
  
  UserRemoteAppLogInfo(const UserRemoteAppLogInfo& from);
  
  inline UserRemoteAppLogInfo& operator=(const UserRemoteAppLogInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const UserRemoteAppLogInfo& default_instance();
  
  void Swap(UserRemoteAppLogInfo* other);
  
  // implements Message ----------------------------------------------
  
  UserRemoteAppLogInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UserRemoteAppLogInfo& from);
  void MergeFrom(const UserRemoteAppLogInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional uint32 next_check_log_space_time = 2;
  inline bool has_next_check_log_space_time() const;
  inline void clear_next_check_log_space_time();
  static const int kNextCheckLogSpaceTimeFieldNumber = 2;
  inline ::google::protobuf::uint32 next_check_log_space_time() const;
  inline void set_next_check_log_space_time(::google::protobuf::uint32 value);
  
  // optional uint64 total_app_log_size = 3;
  inline bool has_total_app_log_size() const;
  inline void clear_total_app_log_size();
  static const int kTotalAppLogSizeFieldNumber = 3;
  inline ::google::protobuf::uint64 total_app_log_size() const;
  inline void set_total_app_log_size(::google::protobuf::uint64 value);
  
  // optional int32 tmp_remain_app_count = 4;
  inline bool has_tmp_remain_app_count() const;
  inline void clear_tmp_remain_app_count();
  static const int kTmpRemainAppCountFieldNumber = 4;
  inline ::google::protobuf::int32 tmp_remain_app_count() const;
  inline void set_tmp_remain_app_count(::google::protobuf::int32 value);
  
  // optional int32 oldest_log_file_app_id = 5;
  inline bool has_oldest_log_file_app_id() const;
  inline void clear_oldest_log_file_app_id();
  static const int kOldestLogFileAppIdFieldNumber = 5;
  inline ::google::protobuf::int32 oldest_log_file_app_id() const;
  inline void set_oldest_log_file_app_id(::google::protobuf::int32 value);
  
  // optional uint32 oldest_log_file_time = 6;
  inline bool has_oldest_log_file_time() const;
  inline void clear_oldest_log_file_time();
  static const int kOldestLogFileTimeFieldNumber = 6;
  inline ::google::protobuf::uint32 oldest_log_file_time() const;
  inline void set_oldest_log_file_time(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:user.UserRemoteAppLogInfo)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::uint32 next_check_log_space_time_;
  ::google::protobuf::uint64 total_app_log_size_;
  ::google::protobuf::int32 tmp_remain_app_count_;
  ::google::protobuf::int32 oldest_log_file_app_id_;
  ::google::protobuf::uint32 oldest_log_file_time_;
  friend void  protobuf_AddDesc_user_2eproto();
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static UserRemoteAppLogInfo* default_instance_;
};
// -------------------------------------------------------------------

class MainPagePluginTables : public ::google::protobuf::Message {
 public:
  MainPagePluginTables();
  virtual ~MainPagePluginTables();
  
  MainPagePluginTables(const MainPagePluginTables& from);
  
  inline MainPagePluginTables& operator=(const MainPagePluginTables& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MainPagePluginTables& default_instance();
  
  void Swap(MainPagePluginTables* other);
  
  // implements Message ----------------------------------------------
  
  MainPagePluginTables* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MainPagePluginTables& from);
  void MergeFrom(const MainPagePluginTables& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional uint32 plugin_id = 1;
  inline bool has_plugin_id() const;
  inline void clear_plugin_id();
  static const int kPluginIdFieldNumber = 1;
  inline ::google::protobuf::uint32 plugin_id() const;
  inline void set_plugin_id(::google::protobuf::uint32 value);
  
  // repeated uint32 table_id_list = 2;
  inline int table_id_list_size() const;
  inline void clear_table_id_list();
  static const int kTableIdListFieldNumber = 2;
  inline ::google::protobuf::uint32 table_id_list(int index) const;
  inline void set_table_id_list(int index, ::google::protobuf::uint32 value);
  inline void add_table_id_list(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      table_id_list() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_table_id_list();
  
  // @@protoc_insertion_point(class_scope:user.MainPagePluginTables)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::uint32 plugin_id_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > table_id_list_;
  friend void  protobuf_AddDesc_user_2eproto();
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MainPagePluginTables* default_instance_;
};
// -------------------------------------------------------------------

class SystemOtherInfo : public ::google::protobuf::Message {
 public:
  SystemOtherInfo();
  virtual ~SystemOtherInfo();
  
  SystemOtherInfo(const SystemOtherInfo& from);
  
  inline SystemOtherInfo& operator=(const SystemOtherInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const SystemOtherInfo& default_instance();
  
  void Swap(SystemOtherInfo* other);
  
  // implements Message ----------------------------------------------
  
  SystemOtherInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SystemOtherInfo& from);
  void MergeFrom(const SystemOtherInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .user.MainPagePluginTables main_plugin_tables = 1;
  inline int main_plugin_tables_size() const;
  inline void clear_main_plugin_tables();
  static const int kMainPluginTablesFieldNumber = 1;
  inline const ::user::MainPagePluginTables& main_plugin_tables(int index) const;
  inline ::user::MainPagePluginTables* mutable_main_plugin_tables(int index);
  inline ::user::MainPagePluginTables* add_main_plugin_tables();
  inline const ::google::protobuf::RepeatedPtrField< ::user::MainPagePluginTables >&
      main_plugin_tables() const;
  inline ::google::protobuf::RepeatedPtrField< ::user::MainPagePluginTables >*
      mutable_main_plugin_tables();
  
  // optional bytes str_version_info = 2;
  inline bool has_str_version_info() const;
  inline void clear_str_version_info();
  static const int kStrVersionInfoFieldNumber = 2;
  inline const ::std::string& str_version_info() const;
  inline void set_str_version_info(const ::std::string& value);
  inline void set_str_version_info(const char* value);
  inline void set_str_version_info(const void* value, size_t size);
  inline ::std::string* mutable_str_version_info();
  
  // optional bytes cust_cloud_url = 3;
  inline bool has_cust_cloud_url() const;
  inline void clear_cust_cloud_url();
  static const int kCustCloudUrlFieldNumber = 3;
  inline const ::std::string& cust_cloud_url() const;
  inline void set_cust_cloud_url(const ::std::string& value);
  inline void set_cust_cloud_url(const char* value);
  inline void set_cust_cloud_url(const void* value, size_t size);
  inline ::std::string* mutable_cust_cloud_url();
  
  // @@protoc_insertion_point(class_scope:user.SystemOtherInfo)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::user::MainPagePluginTables > main_plugin_tables_;
  ::std::string* str_version_info_;
  static const ::std::string _default_str_version_info_;
  ::std::string* cust_cloud_url_;
  static const ::std::string _default_cust_cloud_url_;
  friend void  protobuf_AddDesc_user_2eproto();
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static SystemOtherInfo* default_instance_;
};
// ===================================================================


// ===================================================================

// UserSessionInfo

// optional int32 bind_DES-PWE_uid = 1;
inline bool UserSessionInfo::has_bind_DES-PWE_uid() const {
  return _has_bit(0);
}
inline void UserSessionInfo::clear_bind_DES-PWE_uid() {
  bind_DES-PWE_uid_ = 0;
  _clear_bit(0);
}
inline ::google::protobuf::int32 UserSessionInfo::bind_DES-PWE_uid() const {
  return bind_DES-PWE_uid_;
}
inline void UserSessionInfo::set_bind_DES-PWE_uid(::google::protobuf::int32 value) {
  _set_bit(0);
  bind_DES-PWE_uid_ = value;
}

// optional bytes bind_DES-PWE_key = 2;
inline bool UserSessionInfo::has_bind_DES-PWE_key() const {
  return _has_bit(1);
}
inline void UserSessionInfo::clear_bind_DES-PWE_key() {
  if (bind_DES-PWE_key_ != &_default_bind_DES-PWE_key_) {
    bind_DES-PWE_key_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& UserSessionInfo::bind_DES-PWE_key() const {
  return *bind_DES-PWE_key_;
}
#ifdef _WEB_LOGIC
inline void UserSessionInfo::set_bind_DES-PWE_key(const ::std::string& value) {
  _set_bit(1);
  if (bind_DES-PWE_key_ == &_default_bind_DES-PWE_key_) {
    bind_DES-PWE_key_ = new ::std::string;
  }
  string sTemp;
  StringUtil::GBK2UTF8(value.c_str(), value.size(), sTemp);
  bind_DES-PWE_key_->assign(sTemp);
}
inline void UserSessionInfo::set_bind_DES-PWE_key(const char* value) {
  _set_bit(1);
  if (bind_DES-PWE_key_ == &_default_bind_DES-PWE_key_) {
    bind_DES-PWE_key_ = new ::std::string;
  }
  string sTemp = value;
  StringUtil::GBK2UTF8(value, sTemp.size(), sTemp);
  bind_DES-PWE_key_->assign(sTemp);
}
inline void UserSessionInfo::set_bind_DES-PWE_key(const void* value, size_t size) {
  _set_bit(1);
  if (bind_DES-PWE_key_ == &_default_bind_DES-PWE_key_) {
    bind_DES-PWE_key_ = new ::std::string;
  }
  string sTemp;
  StringUtil::GBK2UTF8(value, size, sTemp);
  bind_DES-PWE_key_->assign(sTemp);
}
#else
inline void UserSessionInfo::set_bind_DES-PWE_key(const ::std::string& value) {
  _set_bit(1);
  if (bind_DES-PWE_key_ == &_default_bind_DES-PWE_key_) {
    bind_DES-PWE_key_ = new ::std::string;
  }
  bind_DES-PWE_key_->assign(value);
}
inline void UserSessionInfo::set_bind_DES-PWE_key(const char* value) {
  _set_bit(1);
  if (bind_DES-PWE_key_ == &_default_bind_DES-PWE_key_) {
    bind_DES-PWE_key_ = new ::std::string;
  }
  bind_DES-PWE_key_->assign(value);
}
inline void UserSessionInfo::set_bind_DES-PWE_key(const void* value, size_t size) {
  _set_bit(1);
  if (bind_DES-PWE_key_ == &_default_bind_DES-PWE_key_) {
    bind_DES-PWE_key_ = new ::std::string;
  }
  bind_DES-PWE_key_->assign(reinterpret_cast<const char*>(value), size);
}
#endif
inline ::std::string* UserSessionInfo::mutable_bind_DES-PWE_key() {
  _set_bit(1);
  if (bind_DES-PWE_key_ == &_default_bind_DES-PWE_key_) {
    bind_DES-PWE_key_ = new ::std::string;
  }
  return bind_DES-PWE_key_;
}

// optional bytes email = 6;
inline bool UserSessionInfo::has_email() const {
  return _has_bit(2);
}
inline void UserSessionInfo::clear_email() {
  if (email_ != &_default_email_) {
    email_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& UserSessionInfo::email() const {
  return *email_;
}
#ifdef _WEB_LOGIC
inline void UserSessionInfo::set_email(const ::std::string& value) {
  _set_bit(2);
  if (email_ == &_default_email_) {
    email_ = new ::std::string;
  }
  string sTemp;
  StringUtil::GBK2UTF8(value.c_str(), value.size(), sTemp);
  email_->assign(sTemp);
}
inline void UserSessionInfo::set_email(const char* value) {
  _set_bit(2);
  if (email_ == &_default_email_) {
    email_ = new ::std::string;
  }
  string sTemp = value;
  StringUtil::GBK2UTF8(value, sTemp.size(), sTemp);
  email_->assign(sTemp);
}
inline void UserSessionInfo::set_email(const void* value, size_t size) {
  _set_bit(2);
  if (email_ == &_default_email_) {
    email_ = new ::std::string;
  }
  string sTemp;
  StringUtil::GBK2UTF8(value, size, sTemp);
  email_->assign(sTemp);
}
#else
inline void UserSessionInfo::set_email(const ::std::string& value) {
  _set_bit(2);
  if (email_ == &_default_email_) {
    email_ = new ::std::string;
  }
  email_->assign(value);
}
inline void UserSessionInfo::set_email(const char* value) {
  _set_bit(2);
  if (email_ == &_default_email_) {
    email_ = new ::std::string;
  }
  email_->assign(value);
}
inline void UserSessionInfo::set_email(const void* value, size_t size) {
  _set_bit(2);
  if (email_ == &_default_email_) {
    email_ = new ::std::string;
  }
  email_->assign(reinterpret_cast<const char*>(value), size);
}
#endif
inline ::std::string* UserSessionInfo::mutable_email() {
  _set_bit(2);
  if (email_ == &_default_email_) {
    email_ = new ::std::string;
  }
  return email_;
}

// optional string mobile = 7;
inline bool UserSessionInfo::has_mobile() const {
  return _has_bit(3);
}
inline void UserSessionInfo::clear_mobile() {
  if (mobile_ != &_default_mobile_) {
    mobile_->clear();
  }
  _clear_bit(3);
}
inline const ::std::string& UserSessionInfo::mobile() const {
  return *mobile_;
}
#ifdef _WEB_LOGIC
inline void UserSessionInfo::set_mobile(const ::std::string& value) {
  _set_bit(3);
  if (mobile_ == &_default_mobile_) {
    mobile_ = new ::std::string;
  }
  string sTemp;
  StringUtil::GBK2UTF8(value.c_str(), value.size(), sTemp);
  mobile_->assign(sTemp);
}
inline void UserSessionInfo::set_mobile(const char* value) {
  _set_bit(3);
  if (mobile_ == &_default_mobile_) {
    mobile_ = new ::std::string;
  }
  string sTemp = value;
  StringUtil::GBK2UTF8(value, sTemp.size(), sTemp);
  mobile_->assign(sTemp);
}
inline void UserSessionInfo::set_mobile(const char* value, size_t size) {
  _set_bit(3);
  if (mobile_ == &_default_mobile_) {
    mobile_ = new ::std::string;
  }
  string sTemp;
  StringUtil::GBK2UTF8(value, size, sTemp);
  mobile_->assign(sTemp);
}
#else
inline void UserSessionInfo::set_mobile(const ::std::string& value) {
  _set_bit(3);
  if (mobile_ == &_default_mobile_) {
    mobile_ = new ::std::string;
  }
  mobile_->assign(value);
}
inline void UserSessionInfo::set_mobile(const char* value) {
  _set_bit(3);
  if (mobile_ == &_default_mobile_) {
    mobile_ = new ::std::string;
  }
  mobile_->assign(value);
}
inline void UserSessionInfo::set_mobile(const char* value, size_t size) {
  _set_bit(3);
  if (mobile_ == &_default_mobile_) {
    mobile_ = new ::std::string;
  }
  mobile_->assign(reinterpret_cast<const char*>(value), size);
}
#endif
inline ::std::string* UserSessionInfo::mutable_mobile() {
  _set_bit(3);
  if (mobile_ == &_default_mobile_) {
    mobile_ = new ::std::string;
  }
  return mobile_;
}

// optional uint32 register_time = 8;
inline bool UserSessionInfo::has_register_time() const {
  return _has_bit(4);
}
inline void UserSessionInfo::clear_register_time() {
  register_time_ = 0u;
  _clear_bit(4);
}
inline ::google::protobuf::uint32 UserSessionInfo::register_time() const {
  return register_time_;
}
inline void UserSessionInfo::set_register_time(::google::protobuf::uint32 value) {
  _set_bit(4);
  register_time_ = value;
}

// optional uint32 op_code_set_time = 9;
inline bool UserSessionInfo::has_op_code_set_time() const {
  return _has_bit(5);
}
inline void UserSessionInfo::clear_op_code_set_time() {
  op_code_set_time_ = 0u;
  _clear_bit(5);
}
inline ::google::protobuf::uint32 UserSessionInfo::op_code_set_time() const {
  return op_code_set_time_;
}
inline void UserSessionInfo::set_op_code_set_time(::google::protobuf::uint32 value) {
  _set_bit(5);
  op_code_set_time_ = value;
}

// optional string op_code_val = 10;
inline bool UserSessionInfo::has_op_code_val() const {
  return _has_bit(6);
}
inline void UserSessionInfo::clear_op_code_val() {
  if (op_code_val_ != &_default_op_code_val_) {
    op_code_val_->clear();
  }
  _clear_bit(6);
}
inline const ::std::string& UserSessionInfo::op_code_val() const {
  return *op_code_val_;
}
#ifdef _WEB_LOGIC
inline void UserSessionInfo::set_op_code_val(const ::std::string& value) {
  _set_bit(6);
  if (op_code_val_ == &_default_op_code_val_) {
    op_code_val_ = new ::std::string;
  }
  string sTemp;
  StringUtil::GBK2UTF8(value.c_str(), value.size(), sTemp);
  op_code_val_->assign(sTemp);
}
inline void UserSessionInfo::set_op_code_val(const char* value) {
  _set_bit(6);
  if (op_code_val_ == &_default_op_code_val_) {
    op_code_val_ = new ::std::string;
  }
  string sTemp = value;
  StringUtil::GBK2UTF8(value, sTemp.size(), sTemp);
  op_code_val_->assign(sTemp);
}
inline void UserSessionInfo::set_op_code_val(const char* value, size_t size) {
  _set_bit(6);
  if (op_code_val_ == &_default_op_code_val_) {
    op_code_val_ = new ::std::string;
  }
  string sTemp;
  StringUtil::GBK2UTF8(value, size, sTemp);
  op_code_val_->assign(sTemp);
}
#else
inline void UserSessionInfo::set_op_code_val(const ::std::string& value) {
  _set_bit(6);
  if (op_code_val_ == &_default_op_code_val_) {
    op_code_val_ = new ::std::string;
  }
  op_code_val_->assign(value);
}
inline void UserSessionInfo::set_op_code_val(const char* value) {
  _set_bit(6);
  if (op_code_val_ == &_default_op_code_val_) {
    op_code_val_ = new ::std::string;
  }
  op_code_val_->assign(value);
}
inline void UserSessionInfo::set_op_code_val(const char* value, size_t size) {
  _set_bit(6);
  if (op_code_val_ == &_default_op_code_val_) {
    op_code_val_ = new ::std::string;
  }
  op_code_val_->assign(reinterpret_cast<const char*>(value), size);
}
#endif
inline ::std::string* UserSessionInfo::mutable_op_code_val() {
  _set_bit(6);
  if (op_code_val_ == &_default_op_code_val_) {
    op_code_val_ = new ::std::string;
  }
  return op_code_val_;
}

// optional uint32 op_check_expire_time = 11;
inline bool UserSessionInfo::has_op_check_expire_time() const {
  return _has_bit(7);
}
inline void UserSessionInfo::clear_op_check_expire_time() {
  op_check_expire_time_ = 0u;
  _clear_bit(7);
}
inline ::google::protobuf::uint32 UserSessionInfo::op_check_expire_time() const {
  return op_check_expire_time_;
}
inline void UserSessionInfo::set_op_check_expire_time(::google::protobuf::uint32 value) {
  _set_bit(7);
  op_check_expire_time_ = value;
}

// optional bytes op_new_email = 12;
inline bool UserSessionInfo::has_op_new_email() const {
  return _has_bit(8);
}
inline void UserSessionInfo::clear_op_new_email() {
  if (op_new_email_ != &_default_op_new_email_) {
    op_new_email_->clear();
  }
  _clear_bit(8);
}
inline const ::std::string& UserSessionInfo::op_new_email() const {
  return *op_new_email_;
}
#ifdef _WEB_LOGIC
inline void UserSessionInfo::set_op_new_email(const ::std::string& value) {
  _set_bit(8);
  if (op_new_email_ == &_default_op_new_email_) {
    op_new_email_ = new ::std::string;
  }
  string sTemp;
  StringUtil::GBK2UTF8(value.c_str(), value.size(), sTemp);
  op_new_email_->assign(sTemp);
}
inline void UserSessionInfo::set_op_new_email(const char* value) {
  _set_bit(8);
  if (op_new_email_ == &_default_op_new_email_) {
    op_new_email_ = new ::std::string;
  }
  string sTemp = value;
  StringUtil::GBK2UTF8(value, sTemp.size(), sTemp);
  op_new_email_->assign(sTemp);
}
inline void UserSessionInfo::set_op_new_email(const void* value, size_t size) {
  _set_bit(8);
  if (op_new_email_ == &_default_op_new_email_) {
    op_new_email_ = new ::std::string;
  }
  string sTemp;
  StringUtil::GBK2UTF8(value, size, sTemp);
  op_new_email_->assign(sTemp);
}
#else
inline void UserSessionInfo::set_op_new_email(const ::std::string& value) {
  _set_bit(8);
  if (op_new_email_ == &_default_op_new_email_) {
    op_new_email_ = new ::std::string;
  }
  op_new_email_->assign(value);
}
inline void UserSessionInfo::set_op_new_email(const char* value) {
  _set_bit(8);
  if (op_new_email_ == &_default_op_new_email_) {
    op_new_email_ = new ::std::string;
  }
  op_new_email_->assign(value);
}
inline void UserSessionInfo::set_op_new_email(const void* value, size_t size) {
  _set_bit(8);
  if (op_new_email_ == &_default_op_new_email_) {
    op_new_email_ = new ::std::string;
  }
  op_new_email_->assign(reinterpret_cast<const char*>(value), size);
}
#endif
inline ::std::string* UserSessionInfo::mutable_op_new_email() {
  _set_bit(8);
  if (op_new_email_ == &_default_op_new_email_) {
    op_new_email_ = new ::std::string;
  }
  return op_new_email_;
}

// optional uint32 su_op_user_id = 14;
inline bool UserSessionInfo::has_su_op_user_id() const {
  return _has_bit(9);
}
inline void UserSessionInfo::clear_su_op_user_id() {
  su_op_user_id_ = 0u;
  _clear_bit(9);
}
inline ::google::protobuf::uint32 UserSessionInfo::su_op_user_id() const {
  return su_op_user_id_;
}
inline void UserSessionInfo::set_su_op_user_id(::google::protobuf::uint32 value) {
  _set_bit(9);
  su_op_user_id_ = value;
}

// optional int32 op_code_type = 15;
inline bool UserSessionInfo::has_op_code_type() const {
  return _has_bit(10);
}
inline void UserSessionInfo::clear_op_code_type() {
  op_code_type_ = 0;
  _clear_bit(10);
}
inline ::google::protobuf::int32 UserSessionInfo::op_code_type() const {
  return op_code_type_;
}
inline void UserSessionInfo::set_op_code_type(::google::protobuf::int32 value) {
  _set_bit(10);
  op_code_type_ = value;
}

// -------------------------------------------------------------------

// UserRemoteAppLogInfo

// optional uint32 next_check_log_space_time = 2;
inline bool UserRemoteAppLogInfo::has_next_check_log_space_time() const {
  return _has_bit(0);
}
inline void UserRemoteAppLogInfo::clear_next_check_log_space_time() {
  next_check_log_space_time_ = 0u;
  _clear_bit(0);
}
inline ::google::protobuf::uint32 UserRemoteAppLogInfo::next_check_log_space_time() const {
  return next_check_log_space_time_;
}
inline void UserRemoteAppLogInfo::set_next_check_log_space_time(::google::protobuf::uint32 value) {
  _set_bit(0);
  next_check_log_space_time_ = value;
}

// optional uint64 total_app_log_size = 3;
inline bool UserRemoteAppLogInfo::has_total_app_log_size() const {
  return _has_bit(1);
}
inline void UserRemoteAppLogInfo::clear_total_app_log_size() {
  total_app_log_size_ = GOOGLE_ULONGLONG(0);
  _clear_bit(1);
}
inline ::google::protobuf::uint64 UserRemoteAppLogInfo::total_app_log_size() const {
  return total_app_log_size_;
}
inline void UserRemoteAppLogInfo::set_total_app_log_size(::google::protobuf::uint64 value) {
  _set_bit(1);
  total_app_log_size_ = value;
}

// optional int32 tmp_remain_app_count = 4;
inline bool UserRemoteAppLogInfo::has_tmp_remain_app_count() const {
  return _has_bit(2);
}
inline void UserRemoteAppLogInfo::clear_tmp_remain_app_count() {
  tmp_remain_app_count_ = 0;
  _clear_bit(2);
}
inline ::google::protobuf::int32 UserRemoteAppLogInfo::tmp_remain_app_count() const {
  return tmp_remain_app_count_;
}
inline void UserRemoteAppLogInfo::set_tmp_remain_app_count(::google::protobuf::int32 value) {
  _set_bit(2);
  tmp_remain_app_count_ = value;
}

// optional int32 oldest_log_file_app_id = 5;
inline bool UserRemoteAppLogInfo::has_oldest_log_file_app_id() const {
  return _has_bit(3);
}
inline void UserRemoteAppLogInfo::clear_oldest_log_file_app_id() {
  oldest_log_file_app_id_ = 0;
  _clear_bit(3);
}
inline ::google::protobuf::int32 UserRemoteAppLogInfo::oldest_log_file_app_id() const {
  return oldest_log_file_app_id_;
}
inline void UserRemoteAppLogInfo::set_oldest_log_file_app_id(::google::protobuf::int32 value) {
  _set_bit(3);
  oldest_log_file_app_id_ = value;
}

// optional uint32 oldest_log_file_time = 6;
inline bool UserRemoteAppLogInfo::has_oldest_log_file_time() const {
  return _has_bit(4);
}
inline void UserRemoteAppLogInfo::clear_oldest_log_file_time() {
  oldest_log_file_time_ = 0u;
  _clear_bit(4);
}
inline ::google::protobuf::uint32 UserRemoteAppLogInfo::oldest_log_file_time() const {
  return oldest_log_file_time_;
}
inline void UserRemoteAppLogInfo::set_oldest_log_file_time(::google::protobuf::uint32 value) {
  _set_bit(4);
  oldest_log_file_time_ = value;
}

// -------------------------------------------------------------------

// MainPagePluginTables

// optional uint32 plugin_id = 1;
inline bool MainPagePluginTables::has_plugin_id() const {
  return _has_bit(0);
}
inline void MainPagePluginTables::clear_plugin_id() {
  plugin_id_ = 0u;
  _clear_bit(0);
}
inline ::google::protobuf::uint32 MainPagePluginTables::plugin_id() const {
  return plugin_id_;
}
inline void MainPagePluginTables::set_plugin_id(::google::protobuf::uint32 value) {
  _set_bit(0);
  plugin_id_ = value;
}

// repeated uint32 table_id_list = 2;
inline int MainPagePluginTables::table_id_list_size() const {
  return table_id_list_.size();
}
inline void MainPagePluginTables::clear_table_id_list() {
  table_id_list_.Clear();
}
inline ::google::protobuf::uint32 MainPagePluginTables::table_id_list(int index) const {
  return table_id_list_.Get(index);
}
inline void MainPagePluginTables::set_table_id_list(int index, ::google::protobuf::uint32 value) {
  table_id_list_.Set(index, value);
}
inline void MainPagePluginTables::add_table_id_list(::google::protobuf::uint32 value) {
  table_id_list_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
MainPagePluginTables::table_id_list() const {
  return table_id_list_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
MainPagePluginTables::mutable_table_id_list() {
  return &table_id_list_;
}

// -------------------------------------------------------------------

// SystemOtherInfo

// repeated .user.MainPagePluginTables main_plugin_tables = 1;
inline int SystemOtherInfo::main_plugin_tables_size() const {
  return main_plugin_tables_.size();
}
inline void SystemOtherInfo::clear_main_plugin_tables() {
  main_plugin_tables_.Clear();
}
inline const ::user::MainPagePluginTables& SystemOtherInfo::main_plugin_tables(int index) const {
  return main_plugin_tables_.Get(index);
}
inline ::user::MainPagePluginTables* SystemOtherInfo::mutable_main_plugin_tables(int index) {
  return main_plugin_tables_.Mutable(index);
}
inline ::user::MainPagePluginTables* SystemOtherInfo::add_main_plugin_tables() {
  return main_plugin_tables_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::user::MainPagePluginTables >&
SystemOtherInfo::main_plugin_tables() const {
  return main_plugin_tables_;
}
inline ::google::protobuf::RepeatedPtrField< ::user::MainPagePluginTables >*
SystemOtherInfo::mutable_main_plugin_tables() {
  return &main_plugin_tables_;
}

// optional bytes str_version_info = 2;
inline bool SystemOtherInfo::has_str_version_info() const {
  return _has_bit(1);
}
inline void SystemOtherInfo::clear_str_version_info() {
  if (str_version_info_ != &_default_str_version_info_) {
    str_version_info_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& SystemOtherInfo::str_version_info() const {
  return *str_version_info_;
}
#ifdef _WEB_LOGIC
inline void SystemOtherInfo::set_str_version_info(const ::std::string& value) {
  _set_bit(1);
  if (str_version_info_ == &_default_str_version_info_) {
    str_version_info_ = new ::std::string;
  }
  string sTemp;
  StringUtil::GBK2UTF8(value.c_str(), value.size(), sTemp);
  str_version_info_->assign(sTemp);
}
inline void SystemOtherInfo::set_str_version_info(const char* value) {
  _set_bit(1);
  if (str_version_info_ == &_default_str_version_info_) {
    str_version_info_ = new ::std::string;
  }
  string sTemp = value;
  StringUtil::GBK2UTF8(value, sTemp.size(), sTemp);
  str_version_info_->assign(sTemp);
}
inline void SystemOtherInfo::set_str_version_info(const void* value, size_t size) {
  _set_bit(1);
  if (str_version_info_ == &_default_str_version_info_) {
    str_version_info_ = new ::std::string;
  }
  string sTemp;
  StringUtil::GBK2UTF8(value, size, sTemp);
  str_version_info_->assign(sTemp);
}
#else
inline void SystemOtherInfo::set_str_version_info(const ::std::string& value) {
  _set_bit(1);
  if (str_version_info_ == &_default_str_version_info_) {
    str_version_info_ = new ::std::string;
  }
  str_version_info_->assign(value);
}
inline void SystemOtherInfo::set_str_version_info(const char* value) {
  _set_bit(1);
  if (str_version_info_ == &_default_str_version_info_) {
    str_version_info_ = new ::std::string;
  }
  str_version_info_->assign(value);
}
inline void SystemOtherInfo::set_str_version_info(const void* value, size_t size) {
  _set_bit(1);
  if (str_version_info_ == &_default_str_version_info_) {
    str_version_info_ = new ::std::string;
  }
  str_version_info_->assign(reinterpret_cast<const char*>(value), size);
}
#endif
inline ::std::string* SystemOtherInfo::mutable_str_version_info() {
  _set_bit(1);
  if (str_version_info_ == &_default_str_version_info_) {
    str_version_info_ = new ::std::string;
  }
  return str_version_info_;
}

// optional bytes cust_cloud_url = 3;
inline bool SystemOtherInfo::has_cust_cloud_url() const {
  return _has_bit(2);
}
inline void SystemOtherInfo::clear_cust_cloud_url() {
  if (cust_cloud_url_ != &_default_cust_cloud_url_) {
    cust_cloud_url_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& SystemOtherInfo::cust_cloud_url() const {
  return *cust_cloud_url_;
}
#ifdef _WEB_LOGIC
inline void SystemOtherInfo::set_cust_cloud_url(const ::std::string& value) {
  _set_bit(2);
  if (cust_cloud_url_ == &_default_cust_cloud_url_) {
    cust_cloud_url_ = new ::std::string;
  }
  string sTemp;
  StringUtil::GBK2UTF8(value.c_str(), value.size(), sTemp);
  cust_cloud_url_->assign(sTemp);
}
inline void SystemOtherInfo::set_cust_cloud_url(const char* value) {
  _set_bit(2);
  if (cust_cloud_url_ == &_default_cust_cloud_url_) {
    cust_cloud_url_ = new ::std::string;
  }
  string sTemp = value;
  StringUtil::GBK2UTF8(value, sTemp.size(), sTemp);
  cust_cloud_url_->assign(sTemp);
}
inline void SystemOtherInfo::set_cust_cloud_url(const void* value, size_t size) {
  _set_bit(2);
  if (cust_cloud_url_ == &_default_cust_cloud_url_) {
    cust_cloud_url_ = new ::std::string;
  }
  string sTemp;
  StringUtil::GBK2UTF8(value, size, sTemp);
  cust_cloud_url_->assign(sTemp);
}
#else
inline void SystemOtherInfo::set_cust_cloud_url(const ::std::string& value) {
  _set_bit(2);
  if (cust_cloud_url_ == &_default_cust_cloud_url_) {
    cust_cloud_url_ = new ::std::string;
  }
  cust_cloud_url_->assign(value);
}
inline void SystemOtherInfo::set_cust_cloud_url(const char* value) {
  _set_bit(2);
  if (cust_cloud_url_ == &_default_cust_cloud_url_) {
    cust_cloud_url_ = new ::std::string;
  }
  cust_cloud_url_->assign(value);
}
inline void SystemOtherInfo::set_cust_cloud_url(const void* value, size_t size) {
  _set_bit(2);
  if (cust_cloud_url_ == &_default_cust_cloud_url_) {
    cust_cloud_url_ = new ::std::string;
  }
  cust_cloud_url_->assign(reinterpret_cast<const char*>(value), size);
}
#endif
inline ::std::string* SystemOtherInfo::mutable_cust_cloud_url() {
  _set_bit(2);
  if (cust_cloud_url_ == &_default_cust_cloud_url_) {
    cust_cloud_url_ = new ::std::string;
  }
  return cust_cloud_url_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace user

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< user::MUSER_FLAG>() {
  return user::MUSER_FLAG_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< user::OP_VCODE_TYPE>() {
  return user::OP_VCODE_TYPE_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_user_2eproto__INCLUDED
