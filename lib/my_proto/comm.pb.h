// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: comm.proto

#ifndef PROTOBUF_comm_2eproto__INCLUDED
#define PROTOBUF_comm_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2003000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2003000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
#ifdef _WEB_LOGIC
#include "CharSetUtil.hpp"
#endif
// @@protoc_insertion_point(includes)

namespace comm {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_comm_2eproto();
void protobuf_AssignDesc_comm_2eproto();
void protobuf_ShutdownFile_comm_2eproto();

class PkgHead;
class HeartInfo;
class AttrInfo;
class ReportAttr;
class AppLogInfo;
class ReportAppLog;
class SendEmailInfo;
class SendWarnInfo;
class QuickProcessToSlowInfo;

enum Command {
  SLOG_CLIENT_SEND_LOG = 501,
  MONITOR_CLIENT_REPORT_ATTR = 502,
  CMD_SLOG_CLIENT_HEART = 504,
  CMD_SLOG_MONITOR_CLIENT_HEART = 505,
  CMD_SLOG_GET_APP_LOG_SIZE_REQ = 506,
  CMD_SLOG_GET_APP_LOG_SIZE_RSP = 507,
  CMD_SLOG_REMOVE_OLD_APP_LOG_FILE = 508,
  CMD_SLOG_OPEN_SEND_WARN = 510,
  CMD_SLOG_OPEN_SEND_EMAIL = 511,
  CMD_SEND_REALINFO_TO_CENTER_REQ = 512,
  CMD_SEND_REALINFO_TO_CENTER_RESP = 513,
  CMD_QUICK_PROCESS_TO_SLOW_REQ = 514
};
bool Command_IsValid(int value);
const Command Command_MIN = SLOG_CLIENT_SEND_LOG;
const Command Command_MAX = CMD_QUICK_PROCESS_TO_SLOW_REQ;
const int Command_ARRAYSIZE = Command_MAX + 1;

const ::google::protobuf::EnumDescriptor* Command_descriptor();
inline const ::std::string& Command_Name(Command value) {
  return ::google::protobuf::internal::NameOfEnum(
    Command_descriptor(), value);
}
inline bool Command_Parse(
    const ::std::string& name, Command* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Command>(
    Command_descriptor(), name, value);
}
enum QuickToSlowCmd {
  QTS_MACHINE_LAST_ATTR_TIME = 1,
  QTS_MACHINE_LAST_LOG_TIME = 2
};
bool QuickToSlowCmd_IsValid(int value);
const QuickToSlowCmd QuickToSlowCmd_MIN = QTS_MACHINE_LAST_ATTR_TIME;
const QuickToSlowCmd QuickToSlowCmd_MAX = QTS_MACHINE_LAST_LOG_TIME;
const int QuickToSlowCmd_ARRAYSIZE = QuickToSlowCmd_MAX + 1;

const ::google::protobuf::EnumDescriptor* QuickToSlowCmd_descriptor();
inline const ::std::string& QuickToSlowCmd_Name(QuickToSlowCmd value) {
  return ::google::protobuf::internal::NameOfEnum(
    QuickToSlowCmd_descriptor(), value);
}
inline bool QuickToSlowCmd_Parse(
    const ::std::string& name, QuickToSlowCmd* value) {
  return ::google::protobuf::internal::ParseNamedEnum<QuickToSlowCmd>(
    QuickToSlowCmd_descriptor(), name, value);
}
// ===================================================================

class PkgHead : public ::google::protobuf::Message {
 public:
  PkgHead();
  virtual ~PkgHead();
  
  PkgHead(const PkgHead& from);
  
  inline PkgHead& operator=(const PkgHead& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const PkgHead& default_instance();
  
  void Swap(PkgHead* other);
  
  // implements Message ----------------------------------------------
  
  PkgHead* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PkgHead& from);
  void MergeFrom(const PkgHead& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .comm.Command en_cmd = 1;
  inline bool has_en_cmd() const;
  inline void clear_en_cmd();
  static const int kEnCmdFieldNumber = 1;
  inline comm::Command en_cmd() const;
  inline void set_en_cmd(comm::Command value);
  
  // required uint32 uint32_seq = 2;
  inline bool has_uint32_seq() const;
  inline void clear_uint32_seq();
  static const int kUint32SeqFieldNumber = 2;
  inline ::google::protobuf::uint32 uint32_seq() const;
  inline void set_uint32_seq(::google::protobuf::uint32 value);
  
  // optional uint32 uint32_result = 3;
  inline bool has_uint32_result() const;
  inline void clear_uint32_result();
  static const int kUint32ResultFieldNumber = 3;
  inline ::google::protobuf::uint32 uint32_result() const;
  inline void set_uint32_result(::google::protobuf::uint32 value);
  
  // optional string str_errmsg = 4;
  inline bool has_str_errmsg() const;
  inline void clear_str_errmsg();
  static const int kStrErrmsgFieldNumber = 4;
  inline const ::std::string& str_errmsg() const;
  inline void set_str_errmsg(const ::std::string& value);
  inline void set_str_errmsg(const char* value);
  inline void set_str_errmsg(const char* value, size_t size);
  inline ::std::string* mutable_str_errmsg();
  
  // optional bytes echo_buf = 5;
  inline bool has_echo_buf() const;
  inline void clear_echo_buf();
  static const int kEchoBufFieldNumber = 5;
  inline const ::std::string& echo_buf() const;
  inline void set_echo_buf(const ::std::string& value);
  inline void set_echo_buf(const char* value);
  inline void set_echo_buf(const void* value, size_t size);
  inline ::std::string* mutable_echo_buf();
  
  // optional uint32 uint32_magic_response_num = 6;
  inline bool has_uint32_magic_response_num() const;
  inline void clear_uint32_magic_response_num();
  static const int kUint32MagicResponseNumFieldNumber = 6;
  inline ::google::protobuf::uint32 uint32_magic_response_num() const;
  inline void set_uint32_magic_response_num(::google::protobuf::uint32 value);
  
  // optional uint32 uid = 7;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 7;
  inline ::google::protobuf::uint32 uid() const;
  inline void set_uid(::google::protobuf::uint32 value);
  
  // optional uint32 req_machine = 8;
  inline bool has_req_machine() const;
  inline void clear_req_machine();
  static const int kReqMachineFieldNumber = 8;
  inline ::google::protobuf::uint32 req_machine() const;
  inline void set_req_machine(::google::protobuf::uint32 value);
  
  // optional uint32 reserved_1 = 9;
  inline bool has_reserved_1() const;
  inline void clear_reserved_1();
  static const int kReserved1FieldNumber = 9;
  inline ::google::protobuf::uint32 reserved_1() const;
  inline void set_reserved_1(::google::protobuf::uint32 value);
  
  // optional uint32 reserved_2 = 10;
  inline bool has_reserved_2() const;
  inline void clear_reserved_2();
  static const int kReserved2FieldNumber = 10;
  inline ::google::protobuf::uint32 reserved_2() const;
  inline void set_reserved_2(::google::protobuf::uint32 value);
  
  // optional uint32 reserved_3 = 11;
  inline bool has_reserved_3() const;
  inline void clear_reserved_3();
  static const int kReserved3FieldNumber = 11;
  inline ::google::protobuf::uint32 reserved_3() const;
  inline void set_reserved_3(::google::protobuf::uint32 value);
  
  // optional uint32 str_reserved_1 = 12;
  inline bool has_str_reserved_1() const;
  inline void clear_str_reserved_1();
  static const int kStrReserved1FieldNumber = 12;
  inline ::google::protobuf::uint32 str_reserved_1() const;
  inline void set_str_reserved_1(::google::protobuf::uint32 value);
  
  // optional uint32 str_reserved_2 = 13;
  inline bool has_str_reserved_2() const;
  inline void clear_str_reserved_2();
  static const int kStrReserved2FieldNumber = 13;
  inline ::google::protobuf::uint32 str_reserved_2() const;
  inline void set_str_reserved_2(::google::protobuf::uint32 value);
  
  // optional uint32 str_reserved_3 = 14;
  inline bool has_str_reserved_3() const;
  inline void clear_str_reserved_3();
  static const int kStrReserved3FieldNumber = 14;
  inline ::google::protobuf::uint32 str_reserved_3() const;
  inline void set_str_reserved_3(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:comm.PkgHead)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  int en_cmd_;
  ::google::protobuf::uint32 uint32_seq_;
  ::google::protobuf::uint32 uint32_result_;
  ::std::string* str_errmsg_;
  static const ::std::string _default_str_errmsg_;
  ::std::string* echo_buf_;
  static const ::std::string _default_echo_buf_;
  ::google::protobuf::uint32 uint32_magic_response_num_;
  ::google::protobuf::uint32 uid_;
  ::google::protobuf::uint32 req_machine_;
  ::google::protobuf::uint32 reserved_1_;
  ::google::protobuf::uint32 reserved_2_;
  ::google::protobuf::uint32 reserved_3_;
  ::google::protobuf::uint32 str_reserved_1_;
  ::google::protobuf::uint32 str_reserved_2_;
  ::google::protobuf::uint32 str_reserved_3_;
  friend void  protobuf_AddDesc_comm_2eproto();
  friend void protobuf_AssignDesc_comm_2eproto();
  friend void protobuf_ShutdownFile_comm_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(14 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static PkgHead* default_instance_;
};
// -------------------------------------------------------------------

class HeartInfo : public ::google::protobuf::Message {
 public:
  HeartInfo();
  virtual ~HeartInfo();
  
  HeartInfo(const HeartInfo& from);
  
  inline HeartInfo& operator=(const HeartInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const HeartInfo& default_instance();
  
  void Swap(HeartInfo* other);
  
  // implements Message ----------------------------------------------
  
  HeartInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HeartInfo& from);
  void MergeFrom(const HeartInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional bytes bytes_req_ip = 1;
  inline bool has_bytes_req_ip() const;
  inline void clear_bytes_req_ip();
  static const int kBytesReqIpFieldNumber = 1;
  inline const ::std::string& bytes_req_ip() const;
  inline void set_bytes_req_ip(const ::std::string& value);
  inline void set_bytes_req_ip(const char* value);
  inline void set_bytes_req_ip(const void* value, size_t size);
  inline ::std::string* mutable_bytes_req_ip();
  
  // @@protoc_insertion_point(class_scope:comm.HeartInfo)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* bytes_req_ip_;
  static const ::std::string _default_bytes_req_ip_;
  friend void  protobuf_AddDesc_comm_2eproto();
  friend void protobuf_AssignDesc_comm_2eproto();
  friend void protobuf_ShutdownFile_comm_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static HeartInfo* default_instance_;
};
// -------------------------------------------------------------------

class AttrInfo : public ::google::protobuf::Message {
 public:
  AttrInfo();
  virtual ~AttrInfo();
  
  AttrInfo(const AttrInfo& from);
  
  inline AttrInfo& operator=(const AttrInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AttrInfo& default_instance();
  
  void Swap(AttrInfo* other);
  
  // implements Message ----------------------------------------------
  
  AttrInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AttrInfo& from);
  void MergeFrom(const AttrInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional uint32 uint32_attr_id = 1;
  inline bool has_uint32_attr_id() const;
  inline void clear_uint32_attr_id();
  static const int kUint32AttrIdFieldNumber = 1;
  inline ::google::protobuf::uint32 uint32_attr_id() const;
  inline void set_uint32_attr_id(::google::protobuf::uint32 value);
  
  // optional uint32 uint32_attr_value = 2;
  inline bool has_uint32_attr_value() const;
  inline void clear_uint32_attr_value();
  static const int kUint32AttrValueFieldNumber = 2;
  inline ::google::protobuf::uint32 uint32_attr_value() const;
  inline void set_uint32_attr_value(::google::protobuf::uint32 value);
  
  // optional bytes str = 3;
  inline bool has_str() const;
  inline void clear_str();
  static const int kStrFieldNumber = 3;
  inline const ::std::string& str() const;
  inline void set_str(const ::std::string& value);
  inline void set_str(const char* value);
  inline void set_str(const void* value, size_t size);
  inline ::std::string* mutable_str();
  
  // @@protoc_insertion_point(class_scope:comm.AttrInfo)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::uint32 uint32_attr_id_;
  ::google::protobuf::uint32 uint32_attr_value_;
  ::std::string* str_;
  static const ::std::string _default_str_;
  friend void  protobuf_AddDesc_comm_2eproto();
  friend void protobuf_AssignDesc_comm_2eproto();
  friend void protobuf_ShutdownFile_comm_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static AttrInfo* default_instance_;
};
// -------------------------------------------------------------------

class ReportAttr : public ::google::protobuf::Message {
 public:
  ReportAttr();
  virtual ~ReportAttr();
  
  ReportAttr(const ReportAttr& from);
  
  inline ReportAttr& operator=(const ReportAttr& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReportAttr& default_instance();
  
  void Swap(ReportAttr* other);
  
  // implements Message ----------------------------------------------
  
  ReportAttr* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReportAttr& from);
  void MergeFrom(const ReportAttr& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional uint32 uint32_client_rep_time = 1;
  inline bool has_uint32_client_rep_time() const;
  inline void clear_uint32_client_rep_time();
  static const int kUint32ClientRepTimeFieldNumber = 1;
  inline ::google::protobuf::uint32 uint32_client_rep_time() const;
  inline void set_uint32_client_rep_time(::google::protobuf::uint32 value);
  
  // optional bytes bytes_report_ip = 2;
  inline bool has_bytes_report_ip() const;
  inline void clear_bytes_report_ip();
  static const int kBytesReportIpFieldNumber = 2;
  inline const ::std::string& bytes_report_ip() const;
  inline void set_bytes_report_ip(const ::std::string& value);
  inline void set_bytes_report_ip(const char* value);
  inline void set_bytes_report_ip(const void* value, size_t size);
  inline ::std::string* mutable_bytes_report_ip();
  
  // repeated .comm.AttrInfo msg_attr_info = 3;
  inline int msg_attr_info_size() const;
  inline void clear_msg_attr_info();
  static const int kMsgAttrInfoFieldNumber = 3;
  inline const ::comm::AttrInfo& msg_attr_info(int index) const;
  inline ::comm::AttrInfo* mutable_msg_attr_info(int index);
  inline ::comm::AttrInfo* add_msg_attr_info();
  inline const ::google::protobuf::RepeatedPtrField< ::comm::AttrInfo >&
      msg_attr_info() const;
  inline ::google::protobuf::RepeatedPtrField< ::comm::AttrInfo >*
      mutable_msg_attr_info();
  
  // optional int32 report_host_id = 4;
  inline bool has_report_host_id() const;
  inline void clear_report_host_id();
  static const int kReportHostIdFieldNumber = 4;
  inline ::google::protobuf::int32 report_host_id() const;
  inline void set_report_host_id(::google::protobuf::int32 value);
  
  // optional uint32 user_master_id = 5 [default = 1];
  inline bool has_user_master_id() const;
  inline void clear_user_master_id();
  static const int kUserMasterIdFieldNumber = 5;
  inline ::google::protobuf::uint32 user_master_id() const;
  inline void set_user_master_id(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:comm.ReportAttr)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::uint32 uint32_client_rep_time_;
  ::std::string* bytes_report_ip_;
  static const ::std::string _default_bytes_report_ip_;
  ::google::protobuf::RepeatedPtrField< ::comm::AttrInfo > msg_attr_info_;
  ::google::protobuf::int32 report_host_id_;
  ::google::protobuf::uint32 user_master_id_;
  friend void  protobuf_AddDesc_comm_2eproto();
  friend void protobuf_AssignDesc_comm_2eproto();
  friend void protobuf_ShutdownFile_comm_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static ReportAttr* default_instance_;
};
// -------------------------------------------------------------------

class AppLogInfo : public ::google::protobuf::Message {
 public:
  AppLogInfo();
  virtual ~AppLogInfo();
  
  AppLogInfo(const AppLogInfo& from);
  
  inline AppLogInfo& operator=(const AppLogInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AppLogInfo& default_instance();
  
  void Swap(AppLogInfo* other);
  
  // implements Message ----------------------------------------------
  
  AppLogInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AppLogInfo& from);
  void MergeFrom(const AppLogInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 uint32_app_id = 1;
  inline bool has_uint32_app_id() const;
  inline void clear_uint32_app_id();
  static const int kUint32AppIdFieldNumber = 1;
  inline ::google::protobuf::uint32 uint32_app_id() const;
  inline void set_uint32_app_id(::google::protobuf::uint32 value);
  
  // required uint32 uint32_module_id = 2;
  inline bool has_uint32_module_id() const;
  inline void clear_uint32_module_id();
  static const int kUint32ModuleIdFieldNumber = 2;
  inline ::google::protobuf::uint32 uint32_module_id() const;
  inline void set_uint32_module_id(::google::protobuf::uint32 value);
  
  // required uint64 uint64_log_time = 3;
  inline bool has_uint64_log_time() const;
  inline void clear_uint64_log_time();
  static const int kUint64LogTimeFieldNumber = 3;
  inline ::google::protobuf::uint64 uint64_log_time() const;
  inline void set_uint64_log_time(::google::protobuf::uint64 value);
  
  // optional uint32 uint32_log_seq = 4;
  inline bool has_uint32_log_seq() const;
  inline void clear_uint32_log_seq();
  static const int kUint32LogSeqFieldNumber = 4;
  inline ::google::protobuf::uint32 uint32_log_seq() const;
  inline void set_uint32_log_seq(::google::protobuf::uint32 value);
  
  // required uint32 uint32_log_type = 5;
  inline bool has_uint32_log_type() const;
  inline void clear_uint32_log_type();
  static const int kUint32LogTypeFieldNumber = 5;
  inline ::google::protobuf::uint32 uint32_log_type() const;
  inline void set_uint32_log_type(::google::protobuf::uint32 value);
  
  // required bytes bytes_log = 6;
  inline bool has_bytes_log() const;
  inline void clear_bytes_log();
  static const int kBytesLogFieldNumber = 6;
  inline const ::std::string& bytes_log() const;
  inline void set_bytes_log(const ::std::string& value);
  inline void set_bytes_log(const char* value);
  inline void set_bytes_log(const void* value, size_t size);
  inline ::std::string* mutable_bytes_log();
  
  // optional bytes bytes_report_ip = 7;
  inline bool has_bytes_report_ip() const;
  inline void clear_bytes_report_ip();
  static const int kBytesReportIpFieldNumber = 7;
  inline const ::std::string& bytes_report_ip() const;
  inline void set_bytes_report_ip(const ::std::string& value);
  inline void set_bytes_report_ip(const char* value);
  inline void set_bytes_report_ip(const void* value, size_t size);
  inline ::std::string* mutable_bytes_report_ip();
  
  // @@protoc_insertion_point(class_scope:comm.AppLogInfo)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::uint32 uint32_app_id_;
  ::google::protobuf::uint32 uint32_module_id_;
  ::google::protobuf::uint64 uint64_log_time_;
  ::google::protobuf::uint32 uint32_log_seq_;
  ::google::protobuf::uint32 uint32_log_type_;
  ::std::string* bytes_log_;
  static const ::std::string _default_bytes_log_;
  ::std::string* bytes_report_ip_;
  static const ::std::string _default_bytes_report_ip_;
  friend void  protobuf_AddDesc_comm_2eproto();
  friend void protobuf_AssignDesc_comm_2eproto();
  friend void protobuf_ShutdownFile_comm_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static AppLogInfo* default_instance_;
};
// -------------------------------------------------------------------

class ReportAppLog : public ::google::protobuf::Message {
 public:
  ReportAppLog();
  virtual ~ReportAppLog();
  
  ReportAppLog(const ReportAppLog& from);
  
  inline ReportAppLog& operator=(const ReportAppLog& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReportAppLog& default_instance();
  
  void Swap(ReportAppLog* other);
  
  // implements Message ----------------------------------------------
  
  ReportAppLog* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReportAppLog& from);
  void MergeFrom(const ReportAppLog& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional uint32 uint32_client_rep_time = 1;
  inline bool has_uint32_client_rep_time() const;
  inline void clear_uint32_client_rep_time();
  static const int kUint32ClientRepTimeFieldNumber = 1;
  inline ::google::protobuf::uint32 uint32_client_rep_time() const;
  inline void set_uint32_client_rep_time(::google::protobuf::uint32 value);
  
  // optional bytes bytes_report_ip = 2;
  inline bool has_bytes_report_ip() const;
  inline void clear_bytes_report_ip();
  static const int kBytesReportIpFieldNumber = 2;
  inline const ::std::string& bytes_report_ip() const;
  inline void set_bytes_report_ip(const ::std::string& value);
  inline void set_bytes_report_ip(const char* value);
  inline void set_bytes_report_ip(const void* value, size_t size);
  inline ::std::string* mutable_bytes_report_ip();
  
  // repeated .comm.AppLogInfo log = 3;
  inline int log_size() const;
  inline void clear_log();
  static const int kLogFieldNumber = 3;
  inline const ::comm::AppLogInfo& log(int index) const;
  inline ::comm::AppLogInfo* mutable_log(int index);
  inline ::comm::AppLogInfo* add_log();
  inline const ::google::protobuf::RepeatedPtrField< ::comm::AppLogInfo >&
      log() const;
  inline ::google::protobuf::RepeatedPtrField< ::comm::AppLogInfo >*
      mutable_log();
  
  // @@protoc_insertion_point(class_scope:comm.ReportAppLog)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::uint32 uint32_client_rep_time_;
  ::std::string* bytes_report_ip_;
  static const ::std::string _default_bytes_report_ip_;
  ::google::protobuf::RepeatedPtrField< ::comm::AppLogInfo > log_;
  friend void  protobuf_AddDesc_comm_2eproto();
  friend void protobuf_AssignDesc_comm_2eproto();
  friend void protobuf_ShutdownFile_comm_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static ReportAppLog* default_instance_;
};
// -------------------------------------------------------------------

class SendEmailInfo : public ::google::protobuf::Message {
 public:
  SendEmailInfo();
  virtual ~SendEmailInfo();
  
  SendEmailInfo(const SendEmailInfo& from);
  
  inline SendEmailInfo& operator=(const SendEmailInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const SendEmailInfo& default_instance();
  
  void Swap(SendEmailInfo* other);
  
  // implements Message ----------------------------------------------
  
  SendEmailInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SendEmailInfo& from);
  void MergeFrom(const SendEmailInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional bytes addr = 1;
  inline bool has_addr() const;
  inline void clear_addr();
  static const int kAddrFieldNumber = 1;
  inline const ::std::string& addr() const;
  inline void set_addr(const ::std::string& value);
  inline void set_addr(const char* value);
  inline void set_addr(const void* value, size_t size);
  inline ::std::string* mutable_addr();
  
  // optional bytes subject = 2;
  inline bool has_subject() const;
  inline void clear_subject();
  static const int kSubjectFieldNumber = 2;
  inline const ::std::string& subject() const;
  inline void set_subject(const ::std::string& value);
  inline void set_subject(const char* value);
  inline void set_subject(const void* value, size_t size);
  inline ::std::string* mutable_subject();
  
  // optional bytes text_body = 3;
  inline bool has_text_body() const;
  inline void clear_text_body();
  static const int kTextBodyFieldNumber = 3;
  inline const ::std::string& text_body() const;
  inline void set_text_body(const ::std::string& value);
  inline void set_text_body(const char* value);
  inline void set_text_body(const void* value, size_t size);
  inline ::std::string* mutable_text_body();
  
  // @@protoc_insertion_point(class_scope:comm.SendEmailInfo)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* addr_;
  static const ::std::string _default_addr_;
  ::std::string* subject_;
  static const ::std::string _default_subject_;
  ::std::string* text_body_;
  static const ::std::string _default_text_body_;
  friend void  protobuf_AddDesc_comm_2eproto();
  friend void protobuf_AssignDesc_comm_2eproto();
  friend void protobuf_ShutdownFile_comm_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static SendEmailInfo* default_instance_;
};
// -------------------------------------------------------------------

class SendWarnInfo : public ::google::protobuf::Message {
 public:
  SendWarnInfo();
  virtual ~SendWarnInfo();
  
  SendWarnInfo(const SendWarnInfo& from);
  
  inline SendWarnInfo& operator=(const SendWarnInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const SendWarnInfo& default_instance();
  
  void Swap(SendWarnInfo* other);
  
  // implements Message ----------------------------------------------
  
  SendWarnInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SendWarnInfo& from);
  void MergeFrom(const SendWarnInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional uint32 attr_id = 1;
  inline bool has_attr_id() const;
  inline void clear_attr_id();
  static const int kAttrIdFieldNumber = 1;
  inline ::google::protobuf::uint32 attr_id() const;
  inline void set_attr_id(::google::protobuf::uint32 value);
  
  // optional bytes attr_name = 2;
  inline bool has_attr_name() const;
  inline void clear_attr_name();
  static const int kAttrNameFieldNumber = 2;
  inline const ::std::string& attr_name() const;
  inline void set_attr_name(const ::std::string& value);
  inline void set_attr_name(const char* value);
  inline void set_attr_name(const void* value, size_t size);
  inline ::std::string* mutable_attr_name();
  
  // optional uint32 start_time = 3;
  inline bool has_start_time() const;
  inline void clear_start_time();
  static const int kStartTimeFieldNumber = 3;
  inline ::google::protobuf::uint32 start_time() const;
  inline void set_start_time(::google::protobuf::uint32 value);
  
  // optional uint32 warn_flag = 4;
  inline bool has_warn_flag() const;
  inline void clear_warn_flag();
  static const int kWarnFlagFieldNumber = 4;
  inline ::google::protobuf::uint32 warn_flag() const;
  inline void set_warn_flag(::google::protobuf::uint32 value);
  
  // optional int32 warn_obj_type_id = 5;
  inline bool has_warn_obj_type_id() const;
  inline void clear_warn_obj_type_id();
  static const int kWarnObjTypeIdFieldNumber = 5;
  inline ::google::protobuf::int32 warn_obj_type_id() const;
  inline void set_warn_obj_type_id(::google::protobuf::int32 value);
  
  // optional bytes warn_obj_type_name = 6;
  inline bool has_warn_obj_type_name() const;
  inline void clear_warn_obj_type_name();
  static const int kWarnObjTypeNameFieldNumber = 6;
  inline const ::std::string& warn_obj_type_name() const;
  inline void set_warn_obj_type_name(const ::std::string& value);
  inline void set_warn_obj_type_name(const char* value);
  inline void set_warn_obj_type_name(const void* value, size_t size);
  inline ::std::string* mutable_warn_obj_type_name();
  
  // optional bytes warn_text = 7;
  inline bool has_warn_text() const;
  inline void clear_warn_text();
  static const int kWarnTextFieldNumber = 7;
  inline const ::std::string& warn_text() const;
  inline void set_warn_text(const ::std::string& value);
  inline void set_warn_text(const char* value);
  inline void set_warn_text(const void* value, size_t size);
  inline ::std::string* mutable_warn_text();
  
  // optional uint32 warn_id = 8;
  inline bool has_warn_id() const;
  inline void clear_warn_id();
  static const int kWarnIdFieldNumber = 8;
  inline ::google::protobuf::uint32 warn_id() const;
  inline void set_warn_id(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:comm.SendWarnInfo)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::uint32 attr_id_;
  ::std::string* attr_name_;
  static const ::std::string _default_attr_name_;
  ::google::protobuf::uint32 start_time_;
  ::google::protobuf::uint32 warn_flag_;
  ::google::protobuf::int32 warn_obj_type_id_;
  ::std::string* warn_obj_type_name_;
  static const ::std::string _default_warn_obj_type_name_;
  ::std::string* warn_text_;
  static const ::std::string _default_warn_text_;
  ::google::protobuf::uint32 warn_id_;
  friend void  protobuf_AddDesc_comm_2eproto();
  friend void protobuf_AssignDesc_comm_2eproto();
  friend void protobuf_ShutdownFile_comm_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static SendWarnInfo* default_instance_;
};
// -------------------------------------------------------------------

class QuickProcessToSlowInfo : public ::google::protobuf::Message {
 public:
  QuickProcessToSlowInfo();
  virtual ~QuickProcessToSlowInfo();
  
  QuickProcessToSlowInfo(const QuickProcessToSlowInfo& from);
  
  inline QuickProcessToSlowInfo& operator=(const QuickProcessToSlowInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const QuickProcessToSlowInfo& default_instance();
  
  void Swap(QuickProcessToSlowInfo* other);
  
  // implements Message ----------------------------------------------
  
  QuickProcessToSlowInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const QuickProcessToSlowInfo& from);
  void MergeFrom(const QuickProcessToSlowInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 machine_id = 1;
  inline bool has_machine_id() const;
  inline void clear_machine_id();
  static const int kMachineIdFieldNumber = 1;
  inline ::google::protobuf::int32 machine_id() const;
  inline void set_machine_id(::google::protobuf::int32 value);
  
  // optional uint32 machine_last_attr_time = 2;
  inline bool has_machine_last_attr_time() const;
  inline void clear_machine_last_attr_time();
  static const int kMachineLastAttrTimeFieldNumber = 2;
  inline ::google::protobuf::uint32 machine_last_attr_time() const;
  inline void set_machine_last_attr_time(::google::protobuf::uint32 value);
  
  // optional uint32 machine_last_log_time = 3;
  inline bool has_machine_last_log_time() const;
  inline void clear_machine_last_log_time();
  static const int kMachineLastLogTimeFieldNumber = 3;
  inline ::google::protobuf::uint32 machine_last_log_time() const;
  inline void set_machine_last_log_time(::google::protobuf::uint32 value);
  
  // optional uint32 user_master_id = 4;
  inline bool has_user_master_id() const;
  inline void clear_user_master_id();
  static const int kUserMasterIdFieldNumber = 4;
  inline ::google::protobuf::uint32 user_master_id() const;
  inline void set_user_master_id(::google::protobuf::uint32 value);
  
  // optional int32 quick_to_slow_cmd = 5;
  inline bool has_quick_to_slow_cmd() const;
  inline void clear_quick_to_slow_cmd();
  static const int kQuickToSlowCmdFieldNumber = 5;
  inline ::google::protobuf::int32 quick_to_slow_cmd() const;
  inline void set_quick_to_slow_cmd(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:comm.QuickProcessToSlowInfo)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::int32 machine_id_;
  ::google::protobuf::uint32 machine_last_attr_time_;
  ::google::protobuf::uint32 machine_last_log_time_;
  ::google::protobuf::uint32 user_master_id_;
  ::google::protobuf::int32 quick_to_slow_cmd_;
  friend void  protobuf_AddDesc_comm_2eproto();
  friend void protobuf_AssignDesc_comm_2eproto();
  friend void protobuf_ShutdownFile_comm_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static QuickProcessToSlowInfo* default_instance_;
};
// ===================================================================


// ===================================================================

// PkgHead

// required .comm.Command en_cmd = 1;
inline bool PkgHead::has_en_cmd() const {
  return _has_bit(0);
}
inline void PkgHead::clear_en_cmd() {
  en_cmd_ = 501;
  _clear_bit(0);
}
inline comm::Command PkgHead::en_cmd() const {
  return static_cast< comm::Command >(en_cmd_);
}
inline void PkgHead::set_en_cmd(comm::Command value) {
  GOOGLE_DCHECK(comm::Command_IsValid(value));
  _set_bit(0);
  en_cmd_ = value;
}

// required uint32 uint32_seq = 2;
inline bool PkgHead::has_uint32_seq() const {
  return _has_bit(1);
}
inline void PkgHead::clear_uint32_seq() {
  uint32_seq_ = 0u;
  _clear_bit(1);
}
inline ::google::protobuf::uint32 PkgHead::uint32_seq() const {
  return uint32_seq_;
}
inline void PkgHead::set_uint32_seq(::google::protobuf::uint32 value) {
  _set_bit(1);
  uint32_seq_ = value;
}

// optional uint32 uint32_result = 3;
inline bool PkgHead::has_uint32_result() const {
  return _has_bit(2);
}
inline void PkgHead::clear_uint32_result() {
  uint32_result_ = 0u;
  _clear_bit(2);
}
inline ::google::protobuf::uint32 PkgHead::uint32_result() const {
  return uint32_result_;
}
inline void PkgHead::set_uint32_result(::google::protobuf::uint32 value) {
  _set_bit(2);
  uint32_result_ = value;
}

// optional string str_errmsg = 4;
inline bool PkgHead::has_str_errmsg() const {
  return _has_bit(3);
}
inline void PkgHead::clear_str_errmsg() {
  if (str_errmsg_ != &_default_str_errmsg_) {
    str_errmsg_->clear();
  }
  _clear_bit(3);
}
inline const ::std::string& PkgHead::str_errmsg() const {
  return *str_errmsg_;
}
#ifdef _WEB_LOGIC
inline void PkgHead::set_str_errmsg(const ::std::string& value) {
  _set_bit(3);
  if (str_errmsg_ == &_default_str_errmsg_) {
    str_errmsg_ = new ::std::string;
  }
  string sTemp;
  StringUtil::GBK2UTF8(value.c_str(), value.size(), sTemp);
  str_errmsg_->assign(sTemp);
}
inline void PkgHead::set_str_errmsg(const char* value) {
  _set_bit(3);
  if (str_errmsg_ == &_default_str_errmsg_) {
    str_errmsg_ = new ::std::string;
  }
  string sTemp = value;
  StringUtil::GBK2UTF8(value, sTemp.size(), sTemp);
  str_errmsg_->assign(sTemp);
}
inline void PkgHead::set_str_errmsg(const char* value, size_t size) {
  _set_bit(3);
  if (str_errmsg_ == &_default_str_errmsg_) {
    str_errmsg_ = new ::std::string;
  }
  string sTemp;
  StringUtil::GBK2UTF8(value, size, sTemp);
  str_errmsg_->assign(sTemp);
}
#else
inline void PkgHead::set_str_errmsg(const ::std::string& value) {
  _set_bit(3);
  if (str_errmsg_ == &_default_str_errmsg_) {
    str_errmsg_ = new ::std::string;
  }
  str_errmsg_->assign(value);
}
inline void PkgHead::set_str_errmsg(const char* value) {
  _set_bit(3);
  if (str_errmsg_ == &_default_str_errmsg_) {
    str_errmsg_ = new ::std::string;
  }
  str_errmsg_->assign(value);
}
inline void PkgHead::set_str_errmsg(const char* value, size_t size) {
  _set_bit(3);
  if (str_errmsg_ == &_default_str_errmsg_) {
    str_errmsg_ = new ::std::string;
  }
  str_errmsg_->assign(reinterpret_cast<const char*>(value), size);
}
#endif
inline ::std::string* PkgHead::mutable_str_errmsg() {
  _set_bit(3);
  if (str_errmsg_ == &_default_str_errmsg_) {
    str_errmsg_ = new ::std::string;
  }
  return str_errmsg_;
}

// optional bytes echo_buf = 5;
inline bool PkgHead::has_echo_buf() const {
  return _has_bit(4);
}
inline void PkgHead::clear_echo_buf() {
  if (echo_buf_ != &_default_echo_buf_) {
    echo_buf_->clear();
  }
  _clear_bit(4);
}
inline const ::std::string& PkgHead::echo_buf() const {
  return *echo_buf_;
}
#ifdef _WEB_LOGIC
inline void PkgHead::set_echo_buf(const ::std::string& value) {
  _set_bit(4);
  if (echo_buf_ == &_default_echo_buf_) {
    echo_buf_ = new ::std::string;
  }
  string sTemp;
  StringUtil::GBK2UTF8(value.c_str(), value.size(), sTemp);
  echo_buf_->assign(sTemp);
}
inline void PkgHead::set_echo_buf(const char* value) {
  _set_bit(4);
  if (echo_buf_ == &_default_echo_buf_) {
    echo_buf_ = new ::std::string;
  }
  string sTemp = value;
  StringUtil::GBK2UTF8(value, sTemp.size(), sTemp);
  echo_buf_->assign(sTemp);
}
inline void PkgHead::set_echo_buf(const void* value, size_t size) {
  _set_bit(4);
  if (echo_buf_ == &_default_echo_buf_) {
    echo_buf_ = new ::std::string;
  }
  string sTemp;
  StringUtil::GBK2UTF8(value, size, sTemp);
  echo_buf_->assign(sTemp);
}
#else
inline void PkgHead::set_echo_buf(const ::std::string& value) {
  _set_bit(4);
  if (echo_buf_ == &_default_echo_buf_) {
    echo_buf_ = new ::std::string;
  }
  echo_buf_->assign(value);
}
inline void PkgHead::set_echo_buf(const char* value) {
  _set_bit(4);
  if (echo_buf_ == &_default_echo_buf_) {
    echo_buf_ = new ::std::string;
  }
  echo_buf_->assign(value);
}
inline void PkgHead::set_echo_buf(const void* value, size_t size) {
  _set_bit(4);
  if (echo_buf_ == &_default_echo_buf_) {
    echo_buf_ = new ::std::string;
  }
  echo_buf_->assign(reinterpret_cast<const char*>(value), size);
}
#endif
inline ::std::string* PkgHead::mutable_echo_buf() {
  _set_bit(4);
  if (echo_buf_ == &_default_echo_buf_) {
    echo_buf_ = new ::std::string;
  }
  return echo_buf_;
}

// optional uint32 uint32_magic_response_num = 6;
inline bool PkgHead::has_uint32_magic_response_num() const {
  return _has_bit(5);
}
inline void PkgHead::clear_uint32_magic_response_num() {
  uint32_magic_response_num_ = 0u;
  _clear_bit(5);
}
inline ::google::protobuf::uint32 PkgHead::uint32_magic_response_num() const {
  return uint32_magic_response_num_;
}
inline void PkgHead::set_uint32_magic_response_num(::google::protobuf::uint32 value) {
  _set_bit(5);
  uint32_magic_response_num_ = value;
}

// optional uint32 uid = 7;
inline bool PkgHead::has_uid() const {
  return _has_bit(6);
}
inline void PkgHead::clear_uid() {
  uid_ = 0u;
  _clear_bit(6);
}
inline ::google::protobuf::uint32 PkgHead::uid() const {
  return uid_;
}
inline void PkgHead::set_uid(::google::protobuf::uint32 value) {
  _set_bit(6);
  uid_ = value;
}

// optional uint32 req_machine = 8;
inline bool PkgHead::has_req_machine() const {
  return _has_bit(7);
}
inline void PkgHead::clear_req_machine() {
  req_machine_ = 0u;
  _clear_bit(7);
}
inline ::google::protobuf::uint32 PkgHead::req_machine() const {
  return req_machine_;
}
inline void PkgHead::set_req_machine(::google::protobuf::uint32 value) {
  _set_bit(7);
  req_machine_ = value;
}

// optional uint32 reserved_1 = 9;
inline bool PkgHead::has_reserved_1() const {
  return _has_bit(8);
}
inline void PkgHead::clear_reserved_1() {
  reserved_1_ = 0u;
  _clear_bit(8);
}
inline ::google::protobuf::uint32 PkgHead::reserved_1() const {
  return reserved_1_;
}
inline void PkgHead::set_reserved_1(::google::protobuf::uint32 value) {
  _set_bit(8);
  reserved_1_ = value;
}

// optional uint32 reserved_2 = 10;
inline bool PkgHead::has_reserved_2() const {
  return _has_bit(9);
}
inline void PkgHead::clear_reserved_2() {
  reserved_2_ = 0u;
  _clear_bit(9);
}
inline ::google::protobuf::uint32 PkgHead::reserved_2() const {
  return reserved_2_;
}
inline void PkgHead::set_reserved_2(::google::protobuf::uint32 value) {
  _set_bit(9);
  reserved_2_ = value;
}

// optional uint32 reserved_3 = 11;
inline bool PkgHead::has_reserved_3() const {
  return _has_bit(10);
}
inline void PkgHead::clear_reserved_3() {
  reserved_3_ = 0u;
  _clear_bit(10);
}
inline ::google::protobuf::uint32 PkgHead::reserved_3() const {
  return reserved_3_;
}
inline void PkgHead::set_reserved_3(::google::protobuf::uint32 value) {
  _set_bit(10);
  reserved_3_ = value;
}

// optional uint32 str_reserved_1 = 12;
inline bool PkgHead::has_str_reserved_1() const {
  return _has_bit(11);
}
inline void PkgHead::clear_str_reserved_1() {
  str_reserved_1_ = 0u;
  _clear_bit(11);
}
inline ::google::protobuf::uint32 PkgHead::str_reserved_1() const {
  return str_reserved_1_;
}
inline void PkgHead::set_str_reserved_1(::google::protobuf::uint32 value) {
  _set_bit(11);
  str_reserved_1_ = value;
}

// optional uint32 str_reserved_2 = 13;
inline bool PkgHead::has_str_reserved_2() const {
  return _has_bit(12);
}
inline void PkgHead::clear_str_reserved_2() {
  str_reserved_2_ = 0u;
  _clear_bit(12);
}
inline ::google::protobuf::uint32 PkgHead::str_reserved_2() const {
  return str_reserved_2_;
}
inline void PkgHead::set_str_reserved_2(::google::protobuf::uint32 value) {
  _set_bit(12);
  str_reserved_2_ = value;
}

// optional uint32 str_reserved_3 = 14;
inline bool PkgHead::has_str_reserved_3() const {
  return _has_bit(13);
}
inline void PkgHead::clear_str_reserved_3() {
  str_reserved_3_ = 0u;
  _clear_bit(13);
}
inline ::google::protobuf::uint32 PkgHead::str_reserved_3() const {
  return str_reserved_3_;
}
inline void PkgHead::set_str_reserved_3(::google::protobuf::uint32 value) {
  _set_bit(13);
  str_reserved_3_ = value;
}

// -------------------------------------------------------------------

// HeartInfo

// optional bytes bytes_req_ip = 1;
inline bool HeartInfo::has_bytes_req_ip() const {
  return _has_bit(0);
}
inline void HeartInfo::clear_bytes_req_ip() {
  if (bytes_req_ip_ != &_default_bytes_req_ip_) {
    bytes_req_ip_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& HeartInfo::bytes_req_ip() const {
  return *bytes_req_ip_;
}
#ifdef _WEB_LOGIC
inline void HeartInfo::set_bytes_req_ip(const ::std::string& value) {
  _set_bit(0);
  if (bytes_req_ip_ == &_default_bytes_req_ip_) {
    bytes_req_ip_ = new ::std::string;
  }
  string sTemp;
  StringUtil::GBK2UTF8(value.c_str(), value.size(), sTemp);
  bytes_req_ip_->assign(sTemp);
}
inline void HeartInfo::set_bytes_req_ip(const char* value) {
  _set_bit(0);
  if (bytes_req_ip_ == &_default_bytes_req_ip_) {
    bytes_req_ip_ = new ::std::string;
  }
  string sTemp = value;
  StringUtil::GBK2UTF8(value, sTemp.size(), sTemp);
  bytes_req_ip_->assign(sTemp);
}
inline void HeartInfo::set_bytes_req_ip(const void* value, size_t size) {
  _set_bit(0);
  if (bytes_req_ip_ == &_default_bytes_req_ip_) {
    bytes_req_ip_ = new ::std::string;
  }
  string sTemp;
  StringUtil::GBK2UTF8(value, size, sTemp);
  bytes_req_ip_->assign(sTemp);
}
#else
inline void HeartInfo::set_bytes_req_ip(const ::std::string& value) {
  _set_bit(0);
  if (bytes_req_ip_ == &_default_bytes_req_ip_) {
    bytes_req_ip_ = new ::std::string;
  }
  bytes_req_ip_->assign(value);
}
inline void HeartInfo::set_bytes_req_ip(const char* value) {
  _set_bit(0);
  if (bytes_req_ip_ == &_default_bytes_req_ip_) {
    bytes_req_ip_ = new ::std::string;
  }
  bytes_req_ip_->assign(value);
}
inline void HeartInfo::set_bytes_req_ip(const void* value, size_t size) {
  _set_bit(0);
  if (bytes_req_ip_ == &_default_bytes_req_ip_) {
    bytes_req_ip_ = new ::std::string;
  }
  bytes_req_ip_->assign(reinterpret_cast<const char*>(value), size);
}
#endif
inline ::std::string* HeartInfo::mutable_bytes_req_ip() {
  _set_bit(0);
  if (bytes_req_ip_ == &_default_bytes_req_ip_) {
    bytes_req_ip_ = new ::std::string;
  }
  return bytes_req_ip_;
}

// -------------------------------------------------------------------

// AttrInfo

// optional uint32 uint32_attr_id = 1;
inline bool AttrInfo::has_uint32_attr_id() const {
  return _has_bit(0);
}
inline void AttrInfo::clear_uint32_attr_id() {
  uint32_attr_id_ = 0u;
  _clear_bit(0);
}
inline ::google::protobuf::uint32 AttrInfo::uint32_attr_id() const {
  return uint32_attr_id_;
}
inline void AttrInfo::set_uint32_attr_id(::google::protobuf::uint32 value) {
  _set_bit(0);
  uint32_attr_id_ = value;
}

// optional uint32 uint32_attr_value = 2;
inline bool AttrInfo::has_uint32_attr_value() const {
  return _has_bit(1);
}
inline void AttrInfo::clear_uint32_attr_value() {
  uint32_attr_value_ = 0u;
  _clear_bit(1);
}
inline ::google::protobuf::uint32 AttrInfo::uint32_attr_value() const {
  return uint32_attr_value_;
}
inline void AttrInfo::set_uint32_attr_value(::google::protobuf::uint32 value) {
  _set_bit(1);
  uint32_attr_value_ = value;
}

// optional bytes str = 3;
inline bool AttrInfo::has_str() const {
  return _has_bit(2);
}
inline void AttrInfo::clear_str() {
  if (str_ != &_default_str_) {
    str_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& AttrInfo::str() const {
  return *str_;
}
#ifdef _WEB_LOGIC
inline void AttrInfo::set_str(const ::std::string& value) {
  _set_bit(2);
  if (str_ == &_default_str_) {
    str_ = new ::std::string;
  }
  string sTemp;
  StringUtil::GBK2UTF8(value.c_str(), value.size(), sTemp);
  str_->assign(sTemp);
}
inline void AttrInfo::set_str(const char* value) {
  _set_bit(2);
  if (str_ == &_default_str_) {
    str_ = new ::std::string;
  }
  string sTemp = value;
  StringUtil::GBK2UTF8(value, sTemp.size(), sTemp);
  str_->assign(sTemp);
}
inline void AttrInfo::set_str(const void* value, size_t size) {
  _set_bit(2);
  if (str_ == &_default_str_) {
    str_ = new ::std::string;
  }
  string sTemp;
  StringUtil::GBK2UTF8(value, size, sTemp);
  str_->assign(sTemp);
}
#else
inline void AttrInfo::set_str(const ::std::string& value) {
  _set_bit(2);
  if (str_ == &_default_str_) {
    str_ = new ::std::string;
  }
  str_->assign(value);
}
inline void AttrInfo::set_str(const char* value) {
  _set_bit(2);
  if (str_ == &_default_str_) {
    str_ = new ::std::string;
  }
  str_->assign(value);
}
inline void AttrInfo::set_str(const void* value, size_t size) {
  _set_bit(2);
  if (str_ == &_default_str_) {
    str_ = new ::std::string;
  }
  str_->assign(reinterpret_cast<const char*>(value), size);
}
#endif
inline ::std::string* AttrInfo::mutable_str() {
  _set_bit(2);
  if (str_ == &_default_str_) {
    str_ = new ::std::string;
  }
  return str_;
}

// -------------------------------------------------------------------

// ReportAttr

// optional uint32 uint32_client_rep_time = 1;
inline bool ReportAttr::has_uint32_client_rep_time() const {
  return _has_bit(0);
}
inline void ReportAttr::clear_uint32_client_rep_time() {
  uint32_client_rep_time_ = 0u;
  _clear_bit(0);
}
inline ::google::protobuf::uint32 ReportAttr::uint32_client_rep_time() const {
  return uint32_client_rep_time_;
}
inline void ReportAttr::set_uint32_client_rep_time(::google::protobuf::uint32 value) {
  _set_bit(0);
  uint32_client_rep_time_ = value;
}

// optional bytes bytes_report_ip = 2;
inline bool ReportAttr::has_bytes_report_ip() const {
  return _has_bit(1);
}
inline void ReportAttr::clear_bytes_report_ip() {
  if (bytes_report_ip_ != &_default_bytes_report_ip_) {
    bytes_report_ip_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& ReportAttr::bytes_report_ip() const {
  return *bytes_report_ip_;
}
#ifdef _WEB_LOGIC
inline void ReportAttr::set_bytes_report_ip(const ::std::string& value) {
  _set_bit(1);
  if (bytes_report_ip_ == &_default_bytes_report_ip_) {
    bytes_report_ip_ = new ::std::string;
  }
  string sTemp;
  StringUtil::GBK2UTF8(value.c_str(), value.size(), sTemp);
  bytes_report_ip_->assign(sTemp);
}
inline void ReportAttr::set_bytes_report_ip(const char* value) {
  _set_bit(1);
  if (bytes_report_ip_ == &_default_bytes_report_ip_) {
    bytes_report_ip_ = new ::std::string;
  }
  string sTemp = value;
  StringUtil::GBK2UTF8(value, sTemp.size(), sTemp);
  bytes_report_ip_->assign(sTemp);
}
inline void ReportAttr::set_bytes_report_ip(const void* value, size_t size) {
  _set_bit(1);
  if (bytes_report_ip_ == &_default_bytes_report_ip_) {
    bytes_report_ip_ = new ::std::string;
  }
  string sTemp;
  StringUtil::GBK2UTF8(value, size, sTemp);
  bytes_report_ip_->assign(sTemp);
}
#else
inline void ReportAttr::set_bytes_report_ip(const ::std::string& value) {
  _set_bit(1);
  if (bytes_report_ip_ == &_default_bytes_report_ip_) {
    bytes_report_ip_ = new ::std::string;
  }
  bytes_report_ip_->assign(value);
}
inline void ReportAttr::set_bytes_report_ip(const char* value) {
  _set_bit(1);
  if (bytes_report_ip_ == &_default_bytes_report_ip_) {
    bytes_report_ip_ = new ::std::string;
  }
  bytes_report_ip_->assign(value);
}
inline void ReportAttr::set_bytes_report_ip(const void* value, size_t size) {
  _set_bit(1);
  if (bytes_report_ip_ == &_default_bytes_report_ip_) {
    bytes_report_ip_ = new ::std::string;
  }
  bytes_report_ip_->assign(reinterpret_cast<const char*>(value), size);
}
#endif
inline ::std::string* ReportAttr::mutable_bytes_report_ip() {
  _set_bit(1);
  if (bytes_report_ip_ == &_default_bytes_report_ip_) {
    bytes_report_ip_ = new ::std::string;
  }
  return bytes_report_ip_;
}

// repeated .comm.AttrInfo msg_attr_info = 3;
inline int ReportAttr::msg_attr_info_size() const {
  return msg_attr_info_.size();
}
inline void ReportAttr::clear_msg_attr_info() {
  msg_attr_info_.Clear();
}
inline const ::comm::AttrInfo& ReportAttr::msg_attr_info(int index) const {
  return msg_attr_info_.Get(index);
}
inline ::comm::AttrInfo* ReportAttr::mutable_msg_attr_info(int index) {
  return msg_attr_info_.Mutable(index);
}
inline ::comm::AttrInfo* ReportAttr::add_msg_attr_info() {
  return msg_attr_info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::comm::AttrInfo >&
ReportAttr::msg_attr_info() const {
  return msg_attr_info_;
}
inline ::google::protobuf::RepeatedPtrField< ::comm::AttrInfo >*
ReportAttr::mutable_msg_attr_info() {
  return &msg_attr_info_;
}

// optional int32 report_host_id = 4;
inline bool ReportAttr::has_report_host_id() const {
  return _has_bit(3);
}
inline void ReportAttr::clear_report_host_id() {
  report_host_id_ = 0;
  _clear_bit(3);
}
inline ::google::protobuf::int32 ReportAttr::report_host_id() const {
  return report_host_id_;
}
inline void ReportAttr::set_report_host_id(::google::protobuf::int32 value) {
  _set_bit(3);
  report_host_id_ = value;
}

// optional uint32 user_master_id = 5 [default = 1];
inline bool ReportAttr::has_user_master_id() const {
  return _has_bit(4);
}
inline void ReportAttr::clear_user_master_id() {
  user_master_id_ = 1u;
  _clear_bit(4);
}
inline ::google::protobuf::uint32 ReportAttr::user_master_id() const {
  return user_master_id_;
}
inline void ReportAttr::set_user_master_id(::google::protobuf::uint32 value) {
  _set_bit(4);
  user_master_id_ = value;
}

// -------------------------------------------------------------------

// AppLogInfo

// required uint32 uint32_app_id = 1;
inline bool AppLogInfo::has_uint32_app_id() const {
  return _has_bit(0);
}
inline void AppLogInfo::clear_uint32_app_id() {
  uint32_app_id_ = 0u;
  _clear_bit(0);
}
inline ::google::protobuf::uint32 AppLogInfo::uint32_app_id() const {
  return uint32_app_id_;
}
inline void AppLogInfo::set_uint32_app_id(::google::protobuf::uint32 value) {
  _set_bit(0);
  uint32_app_id_ = value;
}

// required uint32 uint32_module_id = 2;
inline bool AppLogInfo::has_uint32_module_id() const {
  return _has_bit(1);
}
inline void AppLogInfo::clear_uint32_module_id() {
  uint32_module_id_ = 0u;
  _clear_bit(1);
}
inline ::google::protobuf::uint32 AppLogInfo::uint32_module_id() const {
  return uint32_module_id_;
}
inline void AppLogInfo::set_uint32_module_id(::google::protobuf::uint32 value) {
  _set_bit(1);
  uint32_module_id_ = value;
}

// required uint64 uint64_log_time = 3;
inline bool AppLogInfo::has_uint64_log_time() const {
  return _has_bit(2);
}
inline void AppLogInfo::clear_uint64_log_time() {
  uint64_log_time_ = GOOGLE_ULONGLONG(0);
  _clear_bit(2);
}
inline ::google::protobuf::uint64 AppLogInfo::uint64_log_time() const {
  return uint64_log_time_;
}
inline void AppLogInfo::set_uint64_log_time(::google::protobuf::uint64 value) {
  _set_bit(2);
  uint64_log_time_ = value;
}

// optional uint32 uint32_log_seq = 4;
inline bool AppLogInfo::has_uint32_log_seq() const {
  return _has_bit(3);
}
inline void AppLogInfo::clear_uint32_log_seq() {
  uint32_log_seq_ = 0u;
  _clear_bit(3);
}
inline ::google::protobuf::uint32 AppLogInfo::uint32_log_seq() const {
  return uint32_log_seq_;
}
inline void AppLogInfo::set_uint32_log_seq(::google::protobuf::uint32 value) {
  _set_bit(3);
  uint32_log_seq_ = value;
}

// required uint32 uint32_log_type = 5;
inline bool AppLogInfo::has_uint32_log_type() const {
  return _has_bit(4);
}
inline void AppLogInfo::clear_uint32_log_type() {
  uint32_log_type_ = 0u;
  _clear_bit(4);
}
inline ::google::protobuf::uint32 AppLogInfo::uint32_log_type() const {
  return uint32_log_type_;
}
inline void AppLogInfo::set_uint32_log_type(::google::protobuf::uint32 value) {
  _set_bit(4);
  uint32_log_type_ = value;
}

// required bytes bytes_log = 6;
inline bool AppLogInfo::has_bytes_log() const {
  return _has_bit(5);
}
inline void AppLogInfo::clear_bytes_log() {
  if (bytes_log_ != &_default_bytes_log_) {
    bytes_log_->clear();
  }
  _clear_bit(5);
}
inline const ::std::string& AppLogInfo::bytes_log() const {
  return *bytes_log_;
}
#ifdef _WEB_LOGIC
inline void AppLogInfo::set_bytes_log(const ::std::string& value) {
  _set_bit(5);
  if (bytes_log_ == &_default_bytes_log_) {
    bytes_log_ = new ::std::string;
  }
  string sTemp;
  StringUtil::GBK2UTF8(value.c_str(), value.size(), sTemp);
  bytes_log_->assign(sTemp);
}
inline void AppLogInfo::set_bytes_log(const char* value) {
  _set_bit(5);
  if (bytes_log_ == &_default_bytes_log_) {
    bytes_log_ = new ::std::string;
  }
  string sTemp = value;
  StringUtil::GBK2UTF8(value, sTemp.size(), sTemp);
  bytes_log_->assign(sTemp);
}
inline void AppLogInfo::set_bytes_log(const void* value, size_t size) {
  _set_bit(5);
  if (bytes_log_ == &_default_bytes_log_) {
    bytes_log_ = new ::std::string;
  }
  string sTemp;
  StringUtil::GBK2UTF8(value, size, sTemp);
  bytes_log_->assign(sTemp);
}
#else
inline void AppLogInfo::set_bytes_log(const ::std::string& value) {
  _set_bit(5);
  if (bytes_log_ == &_default_bytes_log_) {
    bytes_log_ = new ::std::string;
  }
  bytes_log_->assign(value);
}
inline void AppLogInfo::set_bytes_log(const char* value) {
  _set_bit(5);
  if (bytes_log_ == &_default_bytes_log_) {
    bytes_log_ = new ::std::string;
  }
  bytes_log_->assign(value);
}
inline void AppLogInfo::set_bytes_log(const void* value, size_t size) {
  _set_bit(5);
  if (bytes_log_ == &_default_bytes_log_) {
    bytes_log_ = new ::std::string;
  }
  bytes_log_->assign(reinterpret_cast<const char*>(value), size);
}
#endif
inline ::std::string* AppLogInfo::mutable_bytes_log() {
  _set_bit(5);
  if (bytes_log_ == &_default_bytes_log_) {
    bytes_log_ = new ::std::string;
  }
  return bytes_log_;
}

// optional bytes bytes_report_ip = 7;
inline bool AppLogInfo::has_bytes_report_ip() const {
  return _has_bit(6);
}
inline void AppLogInfo::clear_bytes_report_ip() {
  if (bytes_report_ip_ != &_default_bytes_report_ip_) {
    bytes_report_ip_->clear();
  }
  _clear_bit(6);
}
inline const ::std::string& AppLogInfo::bytes_report_ip() const {
  return *bytes_report_ip_;
}
#ifdef _WEB_LOGIC
inline void AppLogInfo::set_bytes_report_ip(const ::std::string& value) {
  _set_bit(6);
  if (bytes_report_ip_ == &_default_bytes_report_ip_) {
    bytes_report_ip_ = new ::std::string;
  }
  string sTemp;
  StringUtil::GBK2UTF8(value.c_str(), value.size(), sTemp);
  bytes_report_ip_->assign(sTemp);
}
inline void AppLogInfo::set_bytes_report_ip(const char* value) {
  _set_bit(6);
  if (bytes_report_ip_ == &_default_bytes_report_ip_) {
    bytes_report_ip_ = new ::std::string;
  }
  string sTemp = value;
  StringUtil::GBK2UTF8(value, sTemp.size(), sTemp);
  bytes_report_ip_->assign(sTemp);
}
inline void AppLogInfo::set_bytes_report_ip(const void* value, size_t size) {
  _set_bit(6);
  if (bytes_report_ip_ == &_default_bytes_report_ip_) {
    bytes_report_ip_ = new ::std::string;
  }
  string sTemp;
  StringUtil::GBK2UTF8(value, size, sTemp);
  bytes_report_ip_->assign(sTemp);
}
#else
inline void AppLogInfo::set_bytes_report_ip(const ::std::string& value) {
  _set_bit(6);
  if (bytes_report_ip_ == &_default_bytes_report_ip_) {
    bytes_report_ip_ = new ::std::string;
  }
  bytes_report_ip_->assign(value);
}
inline void AppLogInfo::set_bytes_report_ip(const char* value) {
  _set_bit(6);
  if (bytes_report_ip_ == &_default_bytes_report_ip_) {
    bytes_report_ip_ = new ::std::string;
  }
  bytes_report_ip_->assign(value);
}
inline void AppLogInfo::set_bytes_report_ip(const void* value, size_t size) {
  _set_bit(6);
  if (bytes_report_ip_ == &_default_bytes_report_ip_) {
    bytes_report_ip_ = new ::std::string;
  }
  bytes_report_ip_->assign(reinterpret_cast<const char*>(value), size);
}
#endif
inline ::std::string* AppLogInfo::mutable_bytes_report_ip() {
  _set_bit(6);
  if (bytes_report_ip_ == &_default_bytes_report_ip_) {
    bytes_report_ip_ = new ::std::string;
  }
  return bytes_report_ip_;
}

// -------------------------------------------------------------------

// ReportAppLog

// optional uint32 uint32_client_rep_time = 1;
inline bool ReportAppLog::has_uint32_client_rep_time() const {
  return _has_bit(0);
}
inline void ReportAppLog::clear_uint32_client_rep_time() {
  uint32_client_rep_time_ = 0u;
  _clear_bit(0);
}
inline ::google::protobuf::uint32 ReportAppLog::uint32_client_rep_time() const {
  return uint32_client_rep_time_;
}
inline void ReportAppLog::set_uint32_client_rep_time(::google::protobuf::uint32 value) {
  _set_bit(0);
  uint32_client_rep_time_ = value;
}

// optional bytes bytes_report_ip = 2;
inline bool ReportAppLog::has_bytes_report_ip() const {
  return _has_bit(1);
}
inline void ReportAppLog::clear_bytes_report_ip() {
  if (bytes_report_ip_ != &_default_bytes_report_ip_) {
    bytes_report_ip_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& ReportAppLog::bytes_report_ip() const {
  return *bytes_report_ip_;
}
#ifdef _WEB_LOGIC
inline void ReportAppLog::set_bytes_report_ip(const ::std::string& value) {
  _set_bit(1);
  if (bytes_report_ip_ == &_default_bytes_report_ip_) {
    bytes_report_ip_ = new ::std::string;
  }
  string sTemp;
  StringUtil::GBK2UTF8(value.c_str(), value.size(), sTemp);
  bytes_report_ip_->assign(sTemp);
}
inline void ReportAppLog::set_bytes_report_ip(const char* value) {
  _set_bit(1);
  if (bytes_report_ip_ == &_default_bytes_report_ip_) {
    bytes_report_ip_ = new ::std::string;
  }
  string sTemp = value;
  StringUtil::GBK2UTF8(value, sTemp.size(), sTemp);
  bytes_report_ip_->assign(sTemp);
}
inline void ReportAppLog::set_bytes_report_ip(const void* value, size_t size) {
  _set_bit(1);
  if (bytes_report_ip_ == &_default_bytes_report_ip_) {
    bytes_report_ip_ = new ::std::string;
  }
  string sTemp;
  StringUtil::GBK2UTF8(value, size, sTemp);
  bytes_report_ip_->assign(sTemp);
}
#else
inline void ReportAppLog::set_bytes_report_ip(const ::std::string& value) {
  _set_bit(1);
  if (bytes_report_ip_ == &_default_bytes_report_ip_) {
    bytes_report_ip_ = new ::std::string;
  }
  bytes_report_ip_->assign(value);
}
inline void ReportAppLog::set_bytes_report_ip(const char* value) {
  _set_bit(1);
  if (bytes_report_ip_ == &_default_bytes_report_ip_) {
    bytes_report_ip_ = new ::std::string;
  }
  bytes_report_ip_->assign(value);
}
inline void ReportAppLog::set_bytes_report_ip(const void* value, size_t size) {
  _set_bit(1);
  if (bytes_report_ip_ == &_default_bytes_report_ip_) {
    bytes_report_ip_ = new ::std::string;
  }
  bytes_report_ip_->assign(reinterpret_cast<const char*>(value), size);
}
#endif
inline ::std::string* ReportAppLog::mutable_bytes_report_ip() {
  _set_bit(1);
  if (bytes_report_ip_ == &_default_bytes_report_ip_) {
    bytes_report_ip_ = new ::std::string;
  }
  return bytes_report_ip_;
}

// repeated .comm.AppLogInfo log = 3;
inline int ReportAppLog::log_size() const {
  return log_.size();
}
inline void ReportAppLog::clear_log() {
  log_.Clear();
}
inline const ::comm::AppLogInfo& ReportAppLog::log(int index) const {
  return log_.Get(index);
}
inline ::comm::AppLogInfo* ReportAppLog::mutable_log(int index) {
  return log_.Mutable(index);
}
inline ::comm::AppLogInfo* ReportAppLog::add_log() {
  return log_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::comm::AppLogInfo >&
ReportAppLog::log() const {
  return log_;
}
inline ::google::protobuf::RepeatedPtrField< ::comm::AppLogInfo >*
ReportAppLog::mutable_log() {
  return &log_;
}

// -------------------------------------------------------------------

// SendEmailInfo

// optional bytes addr = 1;
inline bool SendEmailInfo::has_addr() const {
  return _has_bit(0);
}
inline void SendEmailInfo::clear_addr() {
  if (addr_ != &_default_addr_) {
    addr_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& SendEmailInfo::addr() const {
  return *addr_;
}
#ifdef _WEB_LOGIC
inline void SendEmailInfo::set_addr(const ::std::string& value) {
  _set_bit(0);
  if (addr_ == &_default_addr_) {
    addr_ = new ::std::string;
  }
  string sTemp;
  StringUtil::GBK2UTF8(value.c_str(), value.size(), sTemp);
  addr_->assign(sTemp);
}
inline void SendEmailInfo::set_addr(const char* value) {
  _set_bit(0);
  if (addr_ == &_default_addr_) {
    addr_ = new ::std::string;
  }
  string sTemp = value;
  StringUtil::GBK2UTF8(value, sTemp.size(), sTemp);
  addr_->assign(sTemp);
}
inline void SendEmailInfo::set_addr(const void* value, size_t size) {
  _set_bit(0);
  if (addr_ == &_default_addr_) {
    addr_ = new ::std::string;
  }
  string sTemp;
  StringUtil::GBK2UTF8(value, size, sTemp);
  addr_->assign(sTemp);
}
#else
inline void SendEmailInfo::set_addr(const ::std::string& value) {
  _set_bit(0);
  if (addr_ == &_default_addr_) {
    addr_ = new ::std::string;
  }
  addr_->assign(value);
}
inline void SendEmailInfo::set_addr(const char* value) {
  _set_bit(0);
  if (addr_ == &_default_addr_) {
    addr_ = new ::std::string;
  }
  addr_->assign(value);
}
inline void SendEmailInfo::set_addr(const void* value, size_t size) {
  _set_bit(0);
  if (addr_ == &_default_addr_) {
    addr_ = new ::std::string;
  }
  addr_->assign(reinterpret_cast<const char*>(value), size);
}
#endif
inline ::std::string* SendEmailInfo::mutable_addr() {
  _set_bit(0);
  if (addr_ == &_default_addr_) {
    addr_ = new ::std::string;
  }
  return addr_;
}

// optional bytes subject = 2;
inline bool SendEmailInfo::has_subject() const {
  return _has_bit(1);
}
inline void SendEmailInfo::clear_subject() {
  if (subject_ != &_default_subject_) {
    subject_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& SendEmailInfo::subject() const {
  return *subject_;
}
#ifdef _WEB_LOGIC
inline void SendEmailInfo::set_subject(const ::std::string& value) {
  _set_bit(1);
  if (subject_ == &_default_subject_) {
    subject_ = new ::std::string;
  }
  string sTemp;
  StringUtil::GBK2UTF8(value.c_str(), value.size(), sTemp);
  subject_->assign(sTemp);
}
inline void SendEmailInfo::set_subject(const char* value) {
  _set_bit(1);
  if (subject_ == &_default_subject_) {
    subject_ = new ::std::string;
  }
  string sTemp = value;
  StringUtil::GBK2UTF8(value, sTemp.size(), sTemp);
  subject_->assign(sTemp);
}
inline void SendEmailInfo::set_subject(const void* value, size_t size) {
  _set_bit(1);
  if (subject_ == &_default_subject_) {
    subject_ = new ::std::string;
  }
  string sTemp;
  StringUtil::GBK2UTF8(value, size, sTemp);
  subject_->assign(sTemp);
}
#else
inline void SendEmailInfo::set_subject(const ::std::string& value) {
  _set_bit(1);
  if (subject_ == &_default_subject_) {
    subject_ = new ::std::string;
  }
  subject_->assign(value);
}
inline void SendEmailInfo::set_subject(const char* value) {
  _set_bit(1);
  if (subject_ == &_default_subject_) {
    subject_ = new ::std::string;
  }
  subject_->assign(value);
}
inline void SendEmailInfo::set_subject(const void* value, size_t size) {
  _set_bit(1);
  if (subject_ == &_default_subject_) {
    subject_ = new ::std::string;
  }
  subject_->assign(reinterpret_cast<const char*>(value), size);
}
#endif
inline ::std::string* SendEmailInfo::mutable_subject() {
  _set_bit(1);
  if (subject_ == &_default_subject_) {
    subject_ = new ::std::string;
  }
  return subject_;
}

// optional bytes text_body = 3;
inline bool SendEmailInfo::has_text_body() const {
  return _has_bit(2);
}
inline void SendEmailInfo::clear_text_body() {
  if (text_body_ != &_default_text_body_) {
    text_body_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& SendEmailInfo::text_body() const {
  return *text_body_;
}
#ifdef _WEB_LOGIC
inline void SendEmailInfo::set_text_body(const ::std::string& value) {
  _set_bit(2);
  if (text_body_ == &_default_text_body_) {
    text_body_ = new ::std::string;
  }
  string sTemp;
  StringUtil::GBK2UTF8(value.c_str(), value.size(), sTemp);
  text_body_->assign(sTemp);
}
inline void SendEmailInfo::set_text_body(const char* value) {
  _set_bit(2);
  if (text_body_ == &_default_text_body_) {
    text_body_ = new ::std::string;
  }
  string sTemp = value;
  StringUtil::GBK2UTF8(value, sTemp.size(), sTemp);
  text_body_->assign(sTemp);
}
inline void SendEmailInfo::set_text_body(const void* value, size_t size) {
  _set_bit(2);
  if (text_body_ == &_default_text_body_) {
    text_body_ = new ::std::string;
  }
  string sTemp;
  StringUtil::GBK2UTF8(value, size, sTemp);
  text_body_->assign(sTemp);
}
#else
inline void SendEmailInfo::set_text_body(const ::std::string& value) {
  _set_bit(2);
  if (text_body_ == &_default_text_body_) {
    text_body_ = new ::std::string;
  }
  text_body_->assign(value);
}
inline void SendEmailInfo::set_text_body(const char* value) {
  _set_bit(2);
  if (text_body_ == &_default_text_body_) {
    text_body_ = new ::std::string;
  }
  text_body_->assign(value);
}
inline void SendEmailInfo::set_text_body(const void* value, size_t size) {
  _set_bit(2);
  if (text_body_ == &_default_text_body_) {
    text_body_ = new ::std::string;
  }
  text_body_->assign(reinterpret_cast<const char*>(value), size);
}
#endif
inline ::std::string* SendEmailInfo::mutable_text_body() {
  _set_bit(2);
  if (text_body_ == &_default_text_body_) {
    text_body_ = new ::std::string;
  }
  return text_body_;
}

// -------------------------------------------------------------------

// SendWarnInfo

// optional uint32 attr_id = 1;
inline bool SendWarnInfo::has_attr_id() const {
  return _has_bit(0);
}
inline void SendWarnInfo::clear_attr_id() {
  attr_id_ = 0u;
  _clear_bit(0);
}
inline ::google::protobuf::uint32 SendWarnInfo::attr_id() const {
  return attr_id_;
}
inline void SendWarnInfo::set_attr_id(::google::protobuf::uint32 value) {
  _set_bit(0);
  attr_id_ = value;
}

// optional bytes attr_name = 2;
inline bool SendWarnInfo::has_attr_name() const {
  return _has_bit(1);
}
inline void SendWarnInfo::clear_attr_name() {
  if (attr_name_ != &_default_attr_name_) {
    attr_name_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& SendWarnInfo::attr_name() const {
  return *attr_name_;
}
#ifdef _WEB_LOGIC
inline void SendWarnInfo::set_attr_name(const ::std::string& value) {
  _set_bit(1);
  if (attr_name_ == &_default_attr_name_) {
    attr_name_ = new ::std::string;
  }
  string sTemp;
  StringUtil::GBK2UTF8(value.c_str(), value.size(), sTemp);
  attr_name_->assign(sTemp);
}
inline void SendWarnInfo::set_attr_name(const char* value) {
  _set_bit(1);
  if (attr_name_ == &_default_attr_name_) {
    attr_name_ = new ::std::string;
  }
  string sTemp = value;
  StringUtil::GBK2UTF8(value, sTemp.size(), sTemp);
  attr_name_->assign(sTemp);
}
inline void SendWarnInfo::set_attr_name(const void* value, size_t size) {
  _set_bit(1);
  if (attr_name_ == &_default_attr_name_) {
    attr_name_ = new ::std::string;
  }
  string sTemp;
  StringUtil::GBK2UTF8(value, size, sTemp);
  attr_name_->assign(sTemp);
}
#else
inline void SendWarnInfo::set_attr_name(const ::std::string& value) {
  _set_bit(1);
  if (attr_name_ == &_default_attr_name_) {
    attr_name_ = new ::std::string;
  }
  attr_name_->assign(value);
}
inline void SendWarnInfo::set_attr_name(const char* value) {
  _set_bit(1);
  if (attr_name_ == &_default_attr_name_) {
    attr_name_ = new ::std::string;
  }
  attr_name_->assign(value);
}
inline void SendWarnInfo::set_attr_name(const void* value, size_t size) {
  _set_bit(1);
  if (attr_name_ == &_default_attr_name_) {
    attr_name_ = new ::std::string;
  }
  attr_name_->assign(reinterpret_cast<const char*>(value), size);
}
#endif
inline ::std::string* SendWarnInfo::mutable_attr_name() {
  _set_bit(1);
  if (attr_name_ == &_default_attr_name_) {
    attr_name_ = new ::std::string;
  }
  return attr_name_;
}

// optional uint32 start_time = 3;
inline bool SendWarnInfo::has_start_time() const {
  return _has_bit(2);
}
inline void SendWarnInfo::clear_start_time() {
  start_time_ = 0u;
  _clear_bit(2);
}
inline ::google::protobuf::uint32 SendWarnInfo::start_time() const {
  return start_time_;
}
inline void SendWarnInfo::set_start_time(::google::protobuf::uint32 value) {
  _set_bit(2);
  start_time_ = value;
}

// optional uint32 warn_flag = 4;
inline bool SendWarnInfo::has_warn_flag() const {
  return _has_bit(3);
}
inline void SendWarnInfo::clear_warn_flag() {
  warn_flag_ = 0u;
  _clear_bit(3);
}
inline ::google::protobuf::uint32 SendWarnInfo::warn_flag() const {
  return warn_flag_;
}
inline void SendWarnInfo::set_warn_flag(::google::protobuf::uint32 value) {
  _set_bit(3);
  warn_flag_ = value;
}

// optional int32 warn_obj_type_id = 5;
inline bool SendWarnInfo::has_warn_obj_type_id() const {
  return _has_bit(4);
}
inline void SendWarnInfo::clear_warn_obj_type_id() {
  warn_obj_type_id_ = 0;
  _clear_bit(4);
}
inline ::google::protobuf::int32 SendWarnInfo::warn_obj_type_id() const {
  return warn_obj_type_id_;
}
inline void SendWarnInfo::set_warn_obj_type_id(::google::protobuf::int32 value) {
  _set_bit(4);
  warn_obj_type_id_ = value;
}

// optional bytes warn_obj_type_name = 6;
inline bool SendWarnInfo::has_warn_obj_type_name() const {
  return _has_bit(5);
}
inline void SendWarnInfo::clear_warn_obj_type_name() {
  if (warn_obj_type_name_ != &_default_warn_obj_type_name_) {
    warn_obj_type_name_->clear();
  }
  _clear_bit(5);
}
inline const ::std::string& SendWarnInfo::warn_obj_type_name() const {
  return *warn_obj_type_name_;
}
#ifdef _WEB_LOGIC
inline void SendWarnInfo::set_warn_obj_type_name(const ::std::string& value) {
  _set_bit(5);
  if (warn_obj_type_name_ == &_default_warn_obj_type_name_) {
    warn_obj_type_name_ = new ::std::string;
  }
  string sTemp;
  StringUtil::GBK2UTF8(value.c_str(), value.size(), sTemp);
  warn_obj_type_name_->assign(sTemp);
}
inline void SendWarnInfo::set_warn_obj_type_name(const char* value) {
  _set_bit(5);
  if (warn_obj_type_name_ == &_default_warn_obj_type_name_) {
    warn_obj_type_name_ = new ::std::string;
  }
  string sTemp = value;
  StringUtil::GBK2UTF8(value, sTemp.size(), sTemp);
  warn_obj_type_name_->assign(sTemp);
}
inline void SendWarnInfo::set_warn_obj_type_name(const void* value, size_t size) {
  _set_bit(5);
  if (warn_obj_type_name_ == &_default_warn_obj_type_name_) {
    warn_obj_type_name_ = new ::std::string;
  }
  string sTemp;
  StringUtil::GBK2UTF8(value, size, sTemp);
  warn_obj_type_name_->assign(sTemp);
}
#else
inline void SendWarnInfo::set_warn_obj_type_name(const ::std::string& value) {
  _set_bit(5);
  if (warn_obj_type_name_ == &_default_warn_obj_type_name_) {
    warn_obj_type_name_ = new ::std::string;
  }
  warn_obj_type_name_->assign(value);
}
inline void SendWarnInfo::set_warn_obj_type_name(const char* value) {
  _set_bit(5);
  if (warn_obj_type_name_ == &_default_warn_obj_type_name_) {
    warn_obj_type_name_ = new ::std::string;
  }
  warn_obj_type_name_->assign(value);
}
inline void SendWarnInfo::set_warn_obj_type_name(const void* value, size_t size) {
  _set_bit(5);
  if (warn_obj_type_name_ == &_default_warn_obj_type_name_) {
    warn_obj_type_name_ = new ::std::string;
  }
  warn_obj_type_name_->assign(reinterpret_cast<const char*>(value), size);
}
#endif
inline ::std::string* SendWarnInfo::mutable_warn_obj_type_name() {
  _set_bit(5);
  if (warn_obj_type_name_ == &_default_warn_obj_type_name_) {
    warn_obj_type_name_ = new ::std::string;
  }
  return warn_obj_type_name_;
}

// optional bytes warn_text = 7;
inline bool SendWarnInfo::has_warn_text() const {
  return _has_bit(6);
}
inline void SendWarnInfo::clear_warn_text() {
  if (warn_text_ != &_default_warn_text_) {
    warn_text_->clear();
  }
  _clear_bit(6);
}
inline const ::std::string& SendWarnInfo::warn_text() const {
  return *warn_text_;
}
#ifdef _WEB_LOGIC
inline void SendWarnInfo::set_warn_text(const ::std::string& value) {
  _set_bit(6);
  if (warn_text_ == &_default_warn_text_) {
    warn_text_ = new ::std::string;
  }
  string sTemp;
  StringUtil::GBK2UTF8(value.c_str(), value.size(), sTemp);
  warn_text_->assign(sTemp);
}
inline void SendWarnInfo::set_warn_text(const char* value) {
  _set_bit(6);
  if (warn_text_ == &_default_warn_text_) {
    warn_text_ = new ::std::string;
  }
  string sTemp = value;
  StringUtil::GBK2UTF8(value, sTemp.size(), sTemp);
  warn_text_->assign(sTemp);
}
inline void SendWarnInfo::set_warn_text(const void* value, size_t size) {
  _set_bit(6);
  if (warn_text_ == &_default_warn_text_) {
    warn_text_ = new ::std::string;
  }
  string sTemp;
  StringUtil::GBK2UTF8(value, size, sTemp);
  warn_text_->assign(sTemp);
}
#else
inline void SendWarnInfo::set_warn_text(const ::std::string& value) {
  _set_bit(6);
  if (warn_text_ == &_default_warn_text_) {
    warn_text_ = new ::std::string;
  }
  warn_text_->assign(value);
}
inline void SendWarnInfo::set_warn_text(const char* value) {
  _set_bit(6);
  if (warn_text_ == &_default_warn_text_) {
    warn_text_ = new ::std::string;
  }
  warn_text_->assign(value);
}
inline void SendWarnInfo::set_warn_text(const void* value, size_t size) {
  _set_bit(6);
  if (warn_text_ == &_default_warn_text_) {
    warn_text_ = new ::std::string;
  }
  warn_text_->assign(reinterpret_cast<const char*>(value), size);
}
#endif
inline ::std::string* SendWarnInfo::mutable_warn_text() {
  _set_bit(6);
  if (warn_text_ == &_default_warn_text_) {
    warn_text_ = new ::std::string;
  }
  return warn_text_;
}

// optional uint32 warn_id = 8;
inline bool SendWarnInfo::has_warn_id() const {
  return _has_bit(7);
}
inline void SendWarnInfo::clear_warn_id() {
  warn_id_ = 0u;
  _clear_bit(7);
}
inline ::google::protobuf::uint32 SendWarnInfo::warn_id() const {
  return warn_id_;
}
inline void SendWarnInfo::set_warn_id(::google::protobuf::uint32 value) {
  _set_bit(7);
  warn_id_ = value;
}

// -------------------------------------------------------------------

// QuickProcessToSlowInfo

// optional int32 machine_id = 1;
inline bool QuickProcessToSlowInfo::has_machine_id() const {
  return _has_bit(0);
}
inline void QuickProcessToSlowInfo::clear_machine_id() {
  machine_id_ = 0;
  _clear_bit(0);
}
inline ::google::protobuf::int32 QuickProcessToSlowInfo::machine_id() const {
  return machine_id_;
}
inline void QuickProcessToSlowInfo::set_machine_id(::google::protobuf::int32 value) {
  _set_bit(0);
  machine_id_ = value;
}

// optional uint32 machine_last_attr_time = 2;
inline bool QuickProcessToSlowInfo::has_machine_last_attr_time() const {
  return _has_bit(1);
}
inline void QuickProcessToSlowInfo::clear_machine_last_attr_time() {
  machine_last_attr_time_ = 0u;
  _clear_bit(1);
}
inline ::google::protobuf::uint32 QuickProcessToSlowInfo::machine_last_attr_time() const {
  return machine_last_attr_time_;
}
inline void QuickProcessToSlowInfo::set_machine_last_attr_time(::google::protobuf::uint32 value) {
  _set_bit(1);
  machine_last_attr_time_ = value;
}

// optional uint32 machine_last_log_time = 3;
inline bool QuickProcessToSlowInfo::has_machine_last_log_time() const {
  return _has_bit(2);
}
inline void QuickProcessToSlowInfo::clear_machine_last_log_time() {
  machine_last_log_time_ = 0u;
  _clear_bit(2);
}
inline ::google::protobuf::uint32 QuickProcessToSlowInfo::machine_last_log_time() const {
  return machine_last_log_time_;
}
inline void QuickProcessToSlowInfo::set_machine_last_log_time(::google::protobuf::uint32 value) {
  _set_bit(2);
  machine_last_log_time_ = value;
}

// optional uint32 user_master_id = 4;
inline bool QuickProcessToSlowInfo::has_user_master_id() const {
  return _has_bit(3);
}
inline void QuickProcessToSlowInfo::clear_user_master_id() {
  user_master_id_ = 0u;
  _clear_bit(3);
}
inline ::google::protobuf::uint32 QuickProcessToSlowInfo::user_master_id() const {
  return user_master_id_;
}
inline void QuickProcessToSlowInfo::set_user_master_id(::google::protobuf::uint32 value) {
  _set_bit(3);
  user_master_id_ = value;
}

// optional int32 quick_to_slow_cmd = 5;
inline bool QuickProcessToSlowInfo::has_quick_to_slow_cmd() const {
  return _has_bit(4);
}
inline void QuickProcessToSlowInfo::clear_quick_to_slow_cmd() {
  quick_to_slow_cmd_ = 0;
  _clear_bit(4);
}
inline ::google::protobuf::int32 QuickProcessToSlowInfo::quick_to_slow_cmd() const {
  return quick_to_slow_cmd_;
}
inline void QuickProcessToSlowInfo::set_quick_to_slow_cmd(::google::protobuf::int32 value) {
  _set_bit(4);
  quick_to_slow_cmd_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace comm

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< comm::Command>() {
  return comm::Command_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< comm::QuickToSlowCmd>() {
  return comm::QuickToSlowCmd_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_comm_2eproto__INCLUDED
